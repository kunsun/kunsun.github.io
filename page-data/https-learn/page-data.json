{"componentChunkName":"component---src-templates-blog-post-js","path":"/https-learn/","result":{"data":{"site":{"siteMetadata":{"title":"kunsun"}},"markdownRemark":{"html":"<p>这个文章讲的特别清楚：<a href=\"https://juejin.im/post/6844903545272041479\">https://juejin.im/post/6844903545272041479</a></p>\n<ol>\n<li>https 相比 http 在请求前多了一个握手的过程；</li>\n<li>在握手时，你和你想访问的网站会交换一个密钥；</li>\n<li>握手完成后，你的请求先用密钥加密才会发出去；</li>\n<li>网站服务器的响应会先用密钥加密再传给你</li>\n</ol>\n<h2>加密方法</h2>\n<ol>\n<li>对称加密： 采用同样的密钥，一个正向加密，另一个反向解密</li>\n<li>非对称加密： 如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的</li>\n</ol>\n<h2>握手</h2>\n<p>密钥在服务器传输时传递是非常耗时的</p>\n<ol>\n<li>服务器发出一张证书，带着共钥</li>\n<li>客户端用公钥加密了一段较短的数据 S， 并返回给服务器</li>\n<li>服务器用私钥解开，拿到 S</li>\n<li>握手步骤完成，S 成为了一个被安全传输到对方手中的对称加密密钥</li>\n</ol>\n<h2>最大的问题</h2>\n<p>这个密钥怎么让传输的双方知晓，同时不被别人知道</p>\n<p>解决方案 1:\n浏览器只要预存好世界上所有 HTTPS 网站的密钥就行\n结论：\n不现实</p>\n<h2>非对称加密+对称加密</h2>\n<ol>\n<li>某服务器拥有用于非对称加密的公钥 A、私钥 A'</li>\n<li>浏览器像网站服务器请求，服务器把公钥 A 明文给传输浏览器</li>\n<li>浏览器随机生成一个用于对称加密的密钥 X，用公钥 A 加密后传给服务器。</li>\n<li>服务器拿到后用私钥 A’解密得到密钥 X</li>\n<li>这样双方就都拥有密钥 X 了，且别人无法知道它。之后双方所有数据都用密钥 X 加密解密。</li>\n</ol>\n<h2>公信力： 数字证书</h2>\n<p>从数字证书中拿到共钥</p>\n<p>证书防止篡改： 数字签名</p>\n<p>数字签名的制作过程：</p>\n<p>CA 拥有非对称加密的私钥和公钥。\nCA 对证书明文信息进行 hash。\n对 hash 后的值用私钥加密，得到数字签名。</p>\n<h2>数字证书浏览器验证过程：</h2>\n<ol>\n<li>拿到证书，得到明文 T，数字签名 S。</li>\n<li>用 CA 机构的公钥对 S 解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。），得到 S’。</li>\n<li>用证书里的 hash 算法对明文 T 进行 hash 得到 T’。</li>\n<li>比较 S’是否等于 T’，等于则表明证书可信。</li>\n</ol>","frontmatter":{"date":"February 02, 2021","path":"/https-learn","title":"HTTPS学习"}}},"pageContext":{"id":"802585bb-52f7-5f1b-a0e5-3a2f3e591cd8"}},"staticQueryHashes":[],"slicesMap":{}}