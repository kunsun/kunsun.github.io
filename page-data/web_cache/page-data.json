{"componentChunkName":"component---src-templates-blog-post-js","path":"/web_cache/","result":{"data":{"site":{"siteMetadata":{"title":"kunsun"}},"markdownRemark":{"html":"<p>说到底缓存最重要的核心就是解决：</p>\n<ol>\n<li>什么时候使用缓存</li>\n<li>什么时候更新缓存</li>\n</ol>\n<h2>强缓存</h2>\n<h3>HTTP1.1</h3>\n<p>服务端使用 Cache-control 这个响应头</p>\n<ol>\n<li>private：表示私有缓存，不能被共有缓存代理服务器缓存，不能在用户间共享，可被用户的浏览器缓存。</li>\n<li>public：表示共有缓存，可被代理服务器缓存，比如 CDN，允许多用户间共享</li>\n<li>max-age：值以秒为单位，表示缓存的内容会在该值后过期</li>\n<li>no-cache：需要使用协商缓存，协商缓存的内容我们后面介绍。注意这个字段并不表示不使用缓存</li>\n<li>no-store：所有内容都不会被缓存</li>\n</ol>\n<p>HTTP 规定，如果 Cache-control 的 max-age 和 Expires 同时出现，那么 max-age 的优先级更高，他会默认覆盖掉 expires。</p>\n<h2>协商缓存</h2>\n<p>从优化的角度来说，我们真正应该关心的是服务器端文件是否已经发生了变化。此时我们需要用到协商缓存策略。</p>\n<ol>\n<li>Last-Modified，If-Modified-Since</li>\n<li>ETag、If-None-Match</li>\n</ol>\n<p>分析第一种：\nLast-Modified 标注的最后修改只能精确到秒级</p>\n<ol>\n<li>浏览器第一次请求资源，服务端在返回资源的响应头中加入 Last-Modified 字段，这个字段表示这个资源在服务器上的最近修改时间</li>\n<li>浏览器收到响应，并记录 Last-Modified 这个响应头的值为 T</li>\n<li>当浏览器再次向服务端请求该资源时，请求头加上 If-Modified-Since 的 header，这个 If-Modified-Since 的值正是上一次请求该资源时，后端返回的 Last-Modified 响应头值 T</li>\n</ol>\n<p>分析第二种：\n服务器集群来处理请求的网站来说， Etag 的匹配概率会大幅降低。所在在这种情况下，使用 Etag 来处理缓存，反而会有更大的开销。</p>\n<ol>\n<li>浏览器第一次请求资源，服务端在返回资源的响应头中加入 Etag，Etag 能够弥补 Last-Modified 的问题，因为 Etag 的生成过程类似文件 hash 值，Etag 是一个字符串，不同文件内容对应不同的 Etag 值</li>\n<li>浏览器收到响应，记录 Etag 这个响应头的值为 E</li>\n<li>浏览器再次跟服务器请求这个资源时，在请求头上加上 If-None-Match，值为 Etag 这个响应头的值 E</li>\n<li>服务端再次收到请求，根据请求头 If-None-Match 的值 E，根据资源生成一个新的 ETag，对比 E 和新的 Etag：如果两值相同，则说明资源没有变化，返回 304 Not Modified，同时携带着新的 ETag 响应头；如果两值不同，就正常返回资源内容，这时也更新 ETag 响应头</li>\n<li>浏览器收到 304 的响应后，就会从缓存中加载资源</li>\n</ol>\n<p>优先级：\nCache-Control > Expires > ETag > Last-Modified</p>\n<ol>\n<li>当用户 Ctrl + F5 强制刷新网页时，浏览器直接从服务器加载，跳过强缓存和协商缓存 相当于在 chrome 控制台打开 no-cache 选项</li>\n<li>当用户仅仅敲击 F5 刷新网页时，跳过强缓存，但是仍然会进行协商缓存过程</li>\n</ol>\n<h2>1. 如何禁止浏览器不缓存静态资源</h2>\n<p>设置请求头：</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">Cache-Control: no-cache, no-store, must-revalidate</code>\n        </deckgo-highlight-code>\n<p>增加版本号：</p>\n<p>meta 标签</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\"  >\n          <code slot=\"code\">&lt;meta\n  http-equiv=&quot;Cache-Control&quot;\n  content=&quot;no-cache, no-store, must-revalidate&quot;\n/&gt;</code>\n        </deckgo-highlight-code>\n<h2>2. 题目二：设置以下 request/response header 会有什么效果？</h2>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">cache-control: max-age=0</code>\n        </deckgo-highlight-code>\n<p>因为 max-age 设置为 0，所以浏览器必须发请求重新验证资源。这时候会走协商缓存机制，可能返回 200 或者 304。</p>\n<h2>3. 题目三：设置以下 request/response header 会有什么效果？</h2>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">cache-control: no-cache</code>\n        </deckgo-highlight-code>\n<p>因为设置 no-cache，所以浏览器必须发请求重新验证资源。这时候会走协商缓存机制。</p>\n<h2>4. 题目四：除了上述方式，还有哪种方式可以设置浏览器必须发请求重新验证资源，走协商缓存机制？</h2>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">cache-control: must-revalidate</code>\n        </deckgo-highlight-code>\n<h2>5. 题目五：设置以下 request/response header 会有什么效果？</h2>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">Cache-Control: max-age=60, must-revalidate</code>\n        </deckgo-highlight-code>\n<p>如果资源在 60s 内再次访问，走强缓存，可以直接返回缓存资源内容；如果超过 60s，则必须发送网络请求到服务端，去验证资源的有效性。</p>\n<h2>6. 题目六：据你的经验，为什么大厂都不怎么用 Etag？</h2>\n<p>很可能被分配到不同的服务器来相应，而根据 ETag 的计算原理，不同的服务器，有可能在资源内容没有变化的情况下，计算出不一样的 Etag，而使得缓存失效。\n而且 Etag 计算较为复杂，所以可能会使得服务端响应变慢。</p>","frontmatter":{"date":"February 02, 2021","path":"/web_cache","title":"Web 缓存"}}},"pageContext":{"id":"e0b651e9-96dd-55b5-a1b9-ad4f2fb47905"}},"staticQueryHashes":[],"slicesMap":{}}