{"componentChunkName":"component---src-templates-blog-post-js","path":"/functional-programing/","result":{"data":{"site":{"siteMetadata":{"title":"kunsun"}},"markdownRemark":{"html":"<p>参考书：<a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/\">https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/</a></p>\n<p>函数式的好处：</p>\n<ol>\n<li>表达力更清晰</li>\n<li>利于复用</li>\n<li>利于维护：同样的输入有同样的结果，在维护和调试代码时能够保持专注</li>\n</ol>\n<h2>纯函数</h2>\n<blockquote>\n<p>一个函数如果输入参数确定，输出结果是唯一确定的，那么它就是纯函数。</p>\n</blockquote>\n<p>纯函数不能修改外部变量，造成副作用，不能调用 Math.radom() 方法以及发送异步请求等，因为这些操作都不具有确定性。</p>\n<p>纯函数的特点：</p>\n<ol>\n<li>无状态</li>\n<li>无副作用</li>\n<li>无关时序</li>\n<li>幂等： 无论调用多少次，结果相同</li>\n</ol>\n<h2>高阶函数</h2>\n<p>函数缓存</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">const memorize = (fn) =&gt; {\n  let cacheMap = {}\n  return function (...args) {\n    const cacheKey = args.join(&quot;_&quot;)\n    if (cacheKey in cacheMap) {\n      return cache[cacheKey]\n    } else {\n      return (cacheMap[cacheKey] = fn.apply(this || {}, args))\n    }\n  }\n}</code>\n        </deckgo-highlight-code>\n<h2>组合</h2>\n<p>更加通用的组合做法是使用 compose 方法，收益非常直观：</p>\n<ul>\n<li>单一功能的小函数更好维护</li>\n<li>通过组合，将单一功能的小函数串联起来，完成复杂的功能</li>\n<li>复用性更好，硬编码更少</li>\n</ul>\n<h2>point free</h2>\n<p>没有形参</p>\n<h2>curry 化分析</h2>\n<p>是把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">const filterLowerNumber = (number) =&gt; {\n  return (array) =&gt; {\n    let result = []\n    for (let i = 0, length = array.length; i &lt; length; i++) {\n      let currentValue = array[i]\n      if (currentValue &lt; number) result.push(currentValue)\n    }\n    return result\n  }\n}\n\nconst filterLowerThan10 = filterLowerNumber(10)\n\nfilterLowerThan10([1, 3, 5, 29, 34])</code>\n        </deckgo-highlight-code>\n<p>例题 1:\n实现 add 方法，要求：\nadd(1)(2) == 3 // true\nadd(1)(2)(3) == 6 // true</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">let add1 = (arg1) =&gt; {\n  let args = [arg1]\n  const fn = (arg2) =&gt; {\n    args.push(arg2)\n    return fn\n  }\n  fn.toString = () =&gt; {\n    return args.reduce((prev, item) =&gt; {\n      return prev + item\n    }, 0)\n  }\n  return fn\n}</code>\n        </deckgo-highlight-code>\n<p>更加通用的实现：</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">const add = (...arg1) =&gt; {\n  let args = [...arg1]\n  const fn = (...arg2) =&gt; {\n    args = [...args, ...arg2]\n    return fn\n  }\n  fn.toString = function () {\n    return args.reduce((prev, item) =&gt; prev + item, 0)\n  }\n  return fn\n}</code>\n        </deckgo-highlight-code>\n<p>例题 2: 编写一个通用的 curry 函数\n首先明确概念，Function.length 指明函数形参的个数</p>\n<p>实现原理：\n先用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数。步骤：</p>\n<ol>\n<li>先逐步接受参数，并进行存储，以供后续使用</li>\n<li>先不进行函数计算，延后执行</li>\n<li>在符合条件时，根据存储的参数，统一传给函数进行计算</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">const curry = (fn) =&gt; {\n  return (tempFn = (...arg1) =&gt; {\n    if (arg1.length &gt;= fn.length) {\n      return fn(...arg1)\n    } else {\n      return (...arg2) =&gt; tempFn(...arg1, ...arg2)\n    }\n  })\n}</code>\n        </deckgo-highlight-code>\n<h2>反 curry 化</h2>\n<p>没有理解</p>\n<h2>偏函数 partial</h2>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">const partial =\n  (fn, ...rest) =&gt;\n  (...args) =&gt;\n    fn(...rest, ...args)</code>\n        </deckgo-highlight-code>\n<h2>函子 functor</h2>\n<h3>of 函子</h3>\n<h3>maybe 函子</h3>","frontmatter":{"date":"February 02, 2021","path":"/functional-programing","title":"函数式编程"}}},"pageContext":{"id":"93679bf0-90d7-522d-aa4c-16f94ffd20a5"}},"staticQueryHashes":[],"slicesMap":{}}