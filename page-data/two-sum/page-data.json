{"componentChunkName":"component---src-templates-blog-post-js","path":"/two-sum/","result":{"data":{"site":{"siteMetadata":{"title":"kunsun"}},"markdownRemark":{"html":"<p>两数之和是一个最基础的算法，今天由浅入深的分析下这个问题。</p>\n<h2>1.0 基础版 普通数组的两数之和</h2>\n<p>给定一个整数数组 nums  和一个目标值 target，请你在该数组中找出和为目标值的那   两个   整数，并返回他们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>\n<h3>示例:</h3>\n<deckgo-highlight-code language=\"log\" terminal=\"carbon\"  >\n          <code slot=\"code\">给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]</code>\n        </deckgo-highlight-code>\n<h3>思路</h3>\n<p>第一种思路，典型的双循环，每个元素都与其他元素进行一个组合，找到第一个符合条件的。</p>\n<p>第二种思路，一次遍历，使用一个 map 存储，key 为数组的值，value 为索引。当遍历到某个元素时，查看对应的值是否存在，如果存在，则返回。</p>\n<h3>解答</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">function twoSum(nums, target) {\n  let map = {}\n  for (let i = 0; i &lt; nums.length; i++) {\n    const key = target - nums[i]\n    const element = nums[i]\n    if (map[element] === undefined) {\n      map[key] = i\n    } else {\n      return [map[element], i]\n    }\n  }\n}</code>\n        </deckgo-highlight-code>\n<h2>2.0 进阶版，有序数组的两数之和</h2>\n<p>给定一个已按照升序排列   的有序数组，找到两个数使得它们相加之和等于目标数。</p>\n<p>函数应该返回这两个下标值 index1 和 index2，其中 index1  必须小于  index2。</p>\n<h3>说明:</h3>\n<p>返回的下标值（index1 和 index2）不是从零开始的。\n你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>\n<h3>示例:</h3>\n<deckgo-highlight-code language=\"log\" terminal=\"carbon\"  >\n          <code slot=\"code\">输入: numbers = [2, 7, 11, 15], target = 9\n输出: [1,2]\n解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</code>\n        </deckgo-highlight-code>\n<h3>思路：</h3>\n<p>注意是有序数组，所以可以给定双指针，一个指向头部，一个指向尾部，当指针所指向的元素之和大于 target，则可以移动大元素的指针向前，反之移动小元素的指针向后，直到和为 target。</p>\n<h3>解答：</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">var twoSum = function (numbers, target) {\n  let len = numbers.length\n  let start = 0\n  let end = len - 1\n  while (start &lt; end) {\n    if (numbers[start] + numbers[end] &gt; target) {\n      end = end - 1\n    } else if (numbers[start] + numbers[end] &lt; target) {\n      start = start + 1\n    } else {\n      return [start + 1, end + 1]\n    }\n  }\n}</code>\n        </deckgo-highlight-code>\n<h2>3.0 两数之和 III - 数据结构设计</h2>\n<p>本题属于 leetcode 会员才能看的，是一个类的设计题，以后要是成为 leetcode 会员再来补上。</p>\n<h2>4.0 终极版 BST 的两数之和</h2>\n<p>给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p>\n<p>案例 1:</p>\n<p>输入:</p>\n<deckgo-highlight-code language=\"log\" terminal=\"carbon\"  >\n          <code slot=\"code\">    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nTarget = 9\n\n输出: True</code>\n        </deckgo-highlight-code>\n<p>案例 2:</p>\n<deckgo-highlight-code language=\"log\" terminal=\"carbon\"  >\n          <code slot=\"code\">输入:\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nTarget = 28\n\n输出: False</code>\n        </deckgo-highlight-code>\n<h3>思路</h3>\n<p>BST 搜索二叉树的特点就是中序遍历后会得到一个有序数组。所以可以先中序遍历，后使用之前的方法。</p>\n<h3>解答</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\"  >\n          <code slot=\"code\">var findTarget = function (root, k) {\n  let arr = []\n  var getTree = function (root) {\n    if (root) {\n      getTree(root.left)\n      arr.push(root.val)\n      getTree(root.right)\n    }\n  }\n  getTree(root)\n  return twoSum(arr, k)\n}\n\nvar twoSum = function (numbers, target) {\n  let len = numbers.length\n  let start = 0\n  let end = len - 1\n  while (start &lt; end) {\n    if (numbers[start] + numbers[end] &gt; target) {\n      end = end - 1\n    } else if (numbers[start] + numbers[end] &lt; target) {\n      start = start + 1\n    } else {\n      return true\n    }\n  }\n  return false\n}</code>\n        </deckgo-highlight-code>","frontmatter":{"date":"July 06, 2020","path":"/two-sum","title":"两数之和"}}},"pageContext":{"id":"4097a794-8e66-5e71-8ce7-160d62373d5e"}},"staticQueryHashes":[],"slicesMap":{}}