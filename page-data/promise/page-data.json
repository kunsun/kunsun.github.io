{"componentChunkName":"component---src-templates-blog-post-js","path":"/promise/","result":{"data":{"site":{"siteMetadata":{"title":"kunsun"}},"markdownRemark":{"html":"<p>Promise 构造函数返回一个 promise 对象实例，这个返回的 promise 具有 then 方法。then 方法中，调用者可以定义两个参数，分别是 onfulfilled 和 onrejected，他们都是函数类型。\n其中 onfulfilled 通过参数可以获取 promise 对象的 resolved 的值；onrejected 获得 promise 对象 rejected 的值。通过这个值，我们来处理异步完成后的逻辑。\n通过这个值，处理异步完成后的逻辑。</p>\n<h2>第一步</h2>\n<p>建立结构</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\"  >\n          <code slot=\"code\">function Promise(executor) {}\nPromise.prototype.then = function (onfulfilled, onrejected) {}</code>\n        </deckgo-highlight-code>\n<h2>第二步</h2>\n<p>完善基本框架</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">function Promise(executor) {\n  const self = this\n  this.status = &quot;pending&quot;\n  this.value = null\n  this.reason = null\n\n  function resolve(value) {\n    self.value = value\n  }\n\n  function reject(value) {\n    self.reason = reason\n  }\n\n  executor(resolve, reject)\n}\n\nPromise.prototype.then = function (\n  onfulfilled = Function.prototype,\n  onrejected = Function.prototype\n) {\n  onfulfilled(this.value)\n  onrejected(this.reason)\n}</code>\n        </deckgo-highlight-code>\n<h2>第三步</h2>\n<p>加入异步逻辑：在合适的时候再执行 resolve</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">function Promise(executor) {\n  this.status = &quot;pending&quot;\n  this.value = null\n  this.reason = null\n  this.onFulfilledFunc = Function.prototype\n  this.onRejectedFunc = Function.prototype\n\n  // 自己的resolve函数，由调用者触发\n  const resolve = (value) =&gt; {\n    if (value instanceof Promise) {\n      return value.then(resolve, reject)\n    }\n    setTimeout(() =&gt; {\n      if (this.status === &quot;pending&quot;) {\n        this.value = value\n        this.status = &quot;fulfilled&quot;\n        this.onFulfilledFunc(this.value)\n      }\n    })\n  }\n  // 自己的reject函数，由调用者触发\n  const reject = (reason) =&gt; {\n    setTimeout(() =&gt; {\n      if (this.status === &quot;pending&quot;) {\n        this.reason = reason\n        this.status = &quot;rejected&quot;\n        this.onRejectedFunc(this.reason)\n      }\n    })\n  }\n  // 调用时执行，参数是自己定义的reject与resolve\n  // 立即执行\n  executor(resolve, reject)\n}\n\nPromise.prototype.then = function (onfulfilled, onreject) {\n  onfulfilled = typeof onfulfilled === &quot;function&quot; ? onfulfilled : (data) =&gt; data\n  onrejected =\n    typeof onrejected === &quot;function&quot;\n      ? onrejected\n      : (error) =&gt; {\n          throw error\n        }\n\n  if (this.status === &quot;fulfilled&quot;) {\n    onfulfilled(this.value)\n  }\n\n  if (this.status === &quot;rejected&quot;) {\n    onrejected(this.value)\n  }\n\n  if (this.status === &quot;pending&quot;) {\n    this.onFulfilledFunc = onfulfilled\n    this.onRejectedFunc = onrejected\n  }\n}\n\n// 调用Promise，executor\nlet promise = new Promise((resolve, reject) =&gt; {\n  resolve(&quot;data&quot;)\n  setTimeout(() =&gt; {\n    resolve(&quot;data&quot;)\n  }, 2000)\n})\n\npromise.then((data) =&gt; {\n  console.log(data)\n})\nconsole.log(1)</code>\n        </deckgo-highlight-code>\n<h2>第四步：加入任务队列逻辑</h2>\n<p>使用 setTimeout 模拟</p>\n<h2>第五步：细节优化</h2>\n<ol>\n<li>抛出错误</li>\n<li>将 onFulfilledFunc 存入数组</li>\n</ol>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\"  >\n          <code slot=\"code\">function Promise(executor) {\n  this.status = &quot;pending&quot;\n  this.value = null\n  this.reason = null\n  this.onRejectedArr = []\n  this.onFulfilledArr = []\n\n  const resolve = (value) =&gt; {\n    if (value instanceof Promise) {\n      return value.then(resolve, reject)\n    }\n    setTimeout(() =&gt; {\n      if (this.status === &quot;pending&quot;) {\n        this.value = value\n        this.status = &quot;fulfilled&quot;\n        this.onFulfilledArr.forEach((func) =&gt; {\n          func(value)\n        })\n      }\n    })\n  }\n\n  const reject = (reason) =&gt; {\n    setTimeout(() =&gt; {\n      if (this.status === &quot;pending&quot;) {\n        this.reason = reason\n        this.status = &quot;rejected&quot;\n        this.onRejectedArr.forEach((func) =&gt; {\n          func(reason)\n        })\n      }\n    })\n  }\n\n  try {\n    executor(resolve, reject)\n  } catch (e) {\n    reject(e)\n  }\n}\n\nPromise.prototype.then = function (onfulfilled, onrejected) {\n  onfulfilled = typeof onfulfilled === &quot;function&quot; ? onfulfilled : (data) =&gt; data\n  onrejected =\n    typeof onrejected === &quot;function&quot;\n      ? onrejected\n      : (error) =&gt; {\n          throw error\n        }\n  if (this.status === &quot;fulfilled&quot;) {\n    onfulfilled(this.value)\n  }\n\n  if (this.status === &quot;rejected&quot;) {\n    onrejected(this.value)\n  }\n  if (this.status === &quot;pending&quot;) {\n    this.onFulfilledArr.push(onfulfilled)\n    this.onRejectedArr.push(onrejected)\n  }\n}</code>\n        </deckgo-highlight-code>\n<h2>第六步：链式调用</h2>\n<p>一个 Promise 实例的 then 方法体 onfulfilled 函数和 onrejected 函数中，是支持再次返回一个 Promise 实例的，也支持返回非 Promise 的普通值。\n修改 Promise.prototype.then:</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">Promise.prototype.then = function (onfulfilled, onrejected) {\n  onfulfilled = typeof onfulfilled === &quot;function&quot; ? onfulfilled : (data) =&gt; data\n  onrejected =\n    typeof onrejected === &quot;function&quot;\n      ? onrejected\n      : (error) =&gt; {\n          throw error\n        }\n  let promise2\n  if (this.status === &quot;fulfilled&quot;) {\n    return (promise2 = new Promise((resolve, reject) =&gt; {\n      setTimeout(() =&gt; {\n        try {\n          let result = onfulfilled(this.value)\n          resolve(result)\n        } catch (e) {\n          reject(e)\n        }\n      })\n    }))\n  }\n  if (this.status === &quot;rejected&quot;) {\n    return (promise2 = new Promise((resolve, reject) =&gt; {\n      setTimeout(() =&gt; {\n        try {\n          let result = onrejected(this.reason)\n          reject(result)\n        } catch (e) {\n          reject(e)\n        }\n      })\n    }))\n  }\n  if (this.status === &quot;pending&quot;) {\n    return (promise2 = new Promise((resolve, reject) =&gt; {\n      this.onFulfilledArray.push(() =&gt; {\n        setTimeout(() =&gt; {\n          try {\n            let result = onfulfilled(this.value)\n            resolve(result)\n          } catch (e) {\n            reject(e)\n          }\n        })\n      })\n      this.onRejectedArr.push(() =&gt; {\n        setTimeout(() =&gt; {\n          try {\n            let result = onrejected(this.reason)\n            resolve(result)\n          } catch (e) {\n            reject(e)\n          }\n        })\n      })\n    }))\n  }\n}</code>\n        </deckgo-highlight-code>\n<h2>第七步：完善链式调用</h2>\n<p>这里的逻辑有些复杂</p>\n<h2>第八步：Promise 穿透实现</h2>\n<p>如果 then 传入的 onfulfilled 与 onrejected 不为函数，则使用默认值</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\"  >\n          <code slot=\"code\">const promise = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    resolve(&quot;kunsun&quot;)\n  }, 2000)\n})\npromise.then(null).then((data) =&gt; {\n  console.log(data)\n})</code>\n        </deckgo-highlight-code>\n<h2>第九步：Promise 静态方法与其他方法实现</h2>\n<h3>Promise.prototype.catch</h3>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">Promise.prototype.catch = function (catchFunc) {\n  return this.then(null, catchFunc)\n}</code>\n        </deckgo-highlight-code>\n<h3>Promise.resolve</h3>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">Promise.resolve = function (value) {\n  return new Promise((resolve, reject) =&gt; {\n    resolve(value)\n  })\n}</code>\n        </deckgo-highlight-code>\n<h3>Promise.reject</h3>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">Promise.reject = function (value) {\n  return new Promise((resolve, reject) =&gt; {\n    reject(value)\n  })\n}</code>\n        </deckgo-highlight-code>\n<h3>Promise.all</h3>\n<blockquote>\n<p>Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都完成时才 resolve。如果参数中 promise 有一个失败（rejected）,此实例失败，失败原因是第一个失败 promise 的结果。</p>\n</blockquote>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\"  >\n          <code slot=\"code\">Promise.all = function (promiseArr) {\n  if (!Array.isArray(promiseArr)) {\n    throw new Error(&quot;参数不是数组&quot;)\n  }\n  return new Promise((resolve, reject) =&gt; {\n    try {\n      let resolveArr = []\n      const length = promiseArr.length\n      for (let i = 0; i &lt; length; i++) {\n        promiseArr[i].then((data) =&gt; {\n          resolveArr.push(data)\n          if (resolveArr.length === length) {\n            resolve(resolveArr)\n          }\n        }, reject)\n      }\n    } catch (e) {\n      reject(e)\n    }\n  })\n}</code>\n        </deckgo-highlight-code>\n<h3>Promise.race</h3>\n<blockquote>\n<p>当 iterable 参数里任何一个成功或失败，直接返回</p>\n</blockquote>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">Promise.race = function (promiseArr) {\n  if (!Array.isArray(promiseArr)) {\n    throw new Error(&quot;参数不是数组&quot;)\n  }\n  return new Promise((resolve, reject) =&gt; {\n    try {\n      const length = primiseArr.length\n      for (let i = 0; i &lt; length; i++) {\n        promiseArray[i].then(resolve, reject)\n      }\n    } catch (e) {\n      reject(e)\n    }\n  })\n}</code>\n        </deckgo-highlight-code>\n<h2>最终代码</h2>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\"  >\n          <code slot=\"code\">function Promise(executor) {\n  this.status = &quot;pending&quot;\n  this.value = null\n  this.reason = null\n  this.onFulfilledArray = []\n  this.onRejectedArray = []\n\n  const resolve = (value) =&gt; {\n    if (value instanceof Promise) {\n      return value.then(resolve, reject)\n    }\n    setTimeout(() =&gt; {\n      if (this.status === &quot;pending&quot;) {\n        this.value = value\n        this.status = &quot;fulfilled&quot;\n\n        this.onFulfilledArray.forEach((func) =&gt; {\n          func(value)\n        })\n      }\n    })\n  }\n\n  const reject = (reason) =&gt; {\n    setTimeout(() =&gt; {\n      if (this.status === &quot;pending&quot;) {\n        this.reason = reason\n        this.status = &quot;rejected&quot;\n\n        this.onRejectedArray.forEach((func) =&gt; {\n          func(reason)\n        })\n      }\n    })\n  }\n\n  try {\n    executor(resolve, reject)\n  } catch (e) {\n    reject(e)\n  }\n}\n\nconst resolvePromise = (promise2, result, resolve, reject) =&gt; {\n  // 当 result 和 promise2 相等时，也就是说 onfulfilled 返回 promise2 时，进行 reject\n  if (result === promise2) {\n    return reject(new TypeError(&quot;error due to circular reference&quot;))\n  }\n\n  // 是否已经执行过 onfulfilled 或者 onrejected\n  let consumed = false\n  let thenable\n\n  if (result instanceof Promise) {\n    if (result.status === &quot;pending&quot;) {\n      result.then(function (data) {\n        resolvePromise(promise2, data, resolve, reject)\n      }, reject)\n    } else {\n      result.then(resolve, reject)\n    }\n    return\n  }\n\n  let isComplexResult = (target) =&gt;\n    (typeof target === &quot;function&quot; || typeof target === &quot;object&quot;) &amp;&amp;\n    target !== null\n  // 如果返回的是疑似 Promise 类型\n  if (isComplexResult(result)) {\n    try {\n      thenable = result.then\n      // 如果返回的是 Promise 类型，具有 then 方法\n      if (typeof thenable === &quot;function&quot;) {\n        thenable.call(\n          result,\n          function (data) {\n            if (consumed) {\n              return\n            }\n            consumed = true\n\n            return resolvePromise(promise2, data, resolve, reject)\n          },\n          function (error) {\n            if (consumed) {\n              return\n            }\n            consumed = true\n\n            return reject(error)\n          }\n        )\n      } else {\n        return resolve(result)\n      }\n    } catch (e) {\n      if (consumed) {\n        return\n      }\n      consumed = true\n      return reject(e)\n    }\n  } else {\n    return resolve(result)\n  }\n}\n\nPromise.prototype.then = function (onfulfilled, onrejected) {\n  onfulfilled = typeof onfulfilled === &quot;function&quot; ? onfulfilled : (data) =&gt; data\n  onrejected =\n    typeof onrejected === &quot;function&quot;\n      ? onrejected\n      : (error) =&gt; {\n          throw error\n        }\n\n  // promise2 将作为 then 方法的返回值\n  let promise2\n\n  if (this.status === &quot;fulfilled&quot;) {\n    return (promise2 = new Promise((resolve, reject) =&gt; {\n      setTimeout(() =&gt; {\n        try {\n          // 这个新的 promise2 resolved 的值为 onfulfilled 的执行结果\n          let result = onfulfilled(this.value)\n          resolvePromise(promise2, result, resolve, reject)\n        } catch (e) {\n          reject(e)\n        }\n      })\n    }))\n  }\n  if (this.status === &quot;rejected&quot;) {\n    return (promise2 = new Promise((resolve, reject) =&gt; {\n      setTimeout(() =&gt; {\n        try {\n          // 这个新的 promise2 reject 的值为 onrejected 的执行结果\n          let result = onrejected(this.reason)\n          resolvePromise(promise2, result, resolve, reject)\n        } catch (e) {\n          reject(e)\n        }\n      })\n    }))\n  }\n  if (this.status === &quot;pending&quot;) {\n    return (promise2 = new Promise((resolve, reject) =&gt; {\n      this.onFulfilledArray.push((value) =&gt; {\n        try {\n          let result = onfulfilled(value)\n          resolvePromise(promise2, result, resolve, reject)\n        } catch (e) {\n          return reject(e)\n        }\n      })\n\n      this.onRejectedArray.push((reason) =&gt; {\n        try {\n          let result = onrejected(reason)\n          resolvePromise(promise2, result, resolve, reject)\n        } catch (e) {\n          return reject(e)\n        }\n      })\n    }))\n  }\n}\n\nPromise.prototype.catch = function (catchFunc) {\n  return this.then(null, catchFunc)\n}\n\nPromise.resolve = function (value) {\n  return new Promise((resolve, reject) =&gt; {\n    resolve(value)\n  })\n}\n\nPromise.reject = function (value) {\n  return new Promise((resolve, reject) =&gt; {\n    reject(value)\n  })\n}\n\nPromise.race = function (promiseArray) {\n  if (!Array.isArray(promiseArray)) {\n    throw new TypeError(&quot;The arguments should be an array!&quot;)\n  }\n  return new Promise((resolve, reject) =&gt; {\n    try {\n      const length = promiseArray.length\n      for (let i = 0; i &lt; length; i++) {\n        promiseArray[i].then(resolve, reject)\n      }\n    } catch (e) {\n      reject(e)\n    }\n  })\n}\n\nPromise.all = function (promiseArray) {\n  if (!Array.isArray(promiseArray)) {\n    throw new TypeError(&quot;The arguments should be an array!&quot;)\n  }\n  return new Promise((resolve, reject) =&gt; {\n    try {\n      let resultArray = []\n\n      const length = promiseArray.length\n\n      for (let i = 0; i &lt; length; i++) {\n        promiseArray[i].then((data) =&gt; {\n          resultArray.push(data)\n\n          if (resultArray.length === length) {\n            resolve(resultArray)\n          }\n        }, reject)\n      }\n    } catch (e) {\n      reject(e)\n    }\n  })\n}</code>\n        </deckgo-highlight-code>\n<h2>总结</h2>\n<ol>\n<li>Promise 可以保持某个 pending 一段时间</li>\n<li>Promise 需要处理错误</li>\n<li>Promise 实例添加多个 then</li>\n<li>链式调用</li>\n<li>Promise 穿透</li>\n<li>静态方法</li>\n</ol>","frontmatter":{"date":"February 02, 2021","path":"/promise","title":"Promise"}}},"pageContext":{"id":"232b1c67-6af5-5d23-b04d-db43728b5a8b"}},"staticQueryHashes":[],"slicesMap":{}}