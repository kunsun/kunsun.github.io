{"componentChunkName":"component---src-templates-blog-post-js","path":"/frontend-design-pattern/","result":{"data":{"site":{"siteMetadata":{"title":"kunsun"}},"markdownRemark":{"html":"<p>六大原则：</p>\n<ol>\n<li>开闭原则： 对扩展开放，对修改关闭</li>\n<li>里氏替换：任何基类可以发挥作用的地方，子类一定可以发挥作用。 继承复用。 里氏替换原则是开闭原则的补充。</li>\n<li>依赖反转原则：针对接口编程，依赖于抽象</li>\n<li>接口隔离原则：减少耦合</li>\n<li>最少知道原则： 一个系统的功能模块应该最大限度地不知晓其他模块的出现，减少感知，模块应相对独立。</li>\n<li>合成复用原则： 尽量使用合成 / 聚合的方式，而不是使用继承。 组合是非常优秀的编程思想，这一点在函数式编程范畴中得到了最大程度的印证。</li>\n</ol>\n<p>三大类型：</p>\n<ol>\n<li>创建型</li>\n<li>结构型</li>\n<li>行为型</li>\n</ol>\n<p>创建型：\n创建型的五种设计模式提供了更加灵活的对象创建方式，同时可以隐藏创建的具体逻辑。与直接使用 new 运算符实例化对象相比，这些模式具有更强的灵活性以及可定制性。</p>\n<p>结构型：\n结构型的七种设计模式关注类和对象的组合，结合继承的概念，这些设计模式能使得对象具有更加灵活的功能设定。</p>\n<p>行为型：\n行为型的十一种设计模式聚焦于对象和类之间的通信，这是构建大型程序架构必不可少的环节。</p>\n<p>参考网站：</p>\n<ol>\n<li><a href=\"https://github.com/DavidCai1993/JsPatterns-ES6\">https://github.com/DavidCai1993/JsPatterns-ES6</a></li>\n<li>《Learning JavaScript Design Patterns》： <a href=\"https://addyosmani.com/resources/essentialjsdesignpatterns/book/#observerpatternjavascript\">https://addyosmani.com/resources/essentialjsdesignpatterns/book/#observerpatternjavascript</a></li>\n<li><a href=\"http://loredanacirstea.github.io/es6-design-patterns/#composite\">http://loredanacirstea.github.io/es6-design-patterns/#composite</a></li>\n</ol>\n<h2>工厂模式</h2>\n<p>创建型工厂模式：</p>\n<ol>\n<li>简单工厂模式（Simple Factory）</li>\n<li>工厂方法模式（Factory Method）</li>\n<li>抽象工厂模式（Abstract Factory）</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">class jQuery {\n  constructor(selector) {\n    super(selector)\n  }\n  //  ....\n}\n\nwindow.$ = function (selector) {\n  return new jQuery(selector)\n}</code>\n        </deckgo-highlight-code>\n<h2>单例模式</h2>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">class Singleton {\n  constructor() {\n    if (!Singleton.instance) {\n      Singleton.instance = this\n    }\n\n    return Singleton.instance\n  }\n}</code>\n        </deckgo-highlight-code>\n<h2>建造者模式</h2>\n<p>分步骤分情况构建一个复杂的对象</p>\n<h2>外观模式</h2>\n<p>例如：</p>\n<ol>\n<li>跨浏览器兼容性的封装</li>\n<li>$(document).ready</li>\n</ol>\n<h2>适配器模式</h2>\n<p>与外观模式思路类似，用于适配两个以上接口不兼容问题</p>\n<h2>享元模式</h2>\n<p>在前端中应用广泛，但是没太懂</p>\n<ol>\n<li>事件代理</li>\n<li>React 合成事件的池化机制</li>\n</ol>\n<h2>代理模式</h2>\n<p>ES6 的 Proxy\nJQuery 的$.proxy 也是代理模式的体现</p>\n<h2>装饰者模式</h2>\n<p>在不改变原对象的基础上，对其对象进行包装和拓展，使原对象能够应对更加复杂的需求\n例子：</p>\n<ol>\n<li>connect</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">export default connect(mapStateToProps, actionCreators)(App)</code>\n        </deckgo-highlight-code>\n<ol start=\"2\">\n<li>antd form</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">class CustomizedForm extends React.Component {}\n\nCustomizedForm = Form.create({})(CustomizedForm)</code>\n        </deckgo-highlight-code>\n<h2>职责链模式</h2>\n<p>建立一个流程链条，一个请求从一端进入，并从一个职责根据需求，流转进入另一个对象，直到找到合适的处理程序\n有点“中间件”的思想</p>\n<h2>策略模式</h2>\n<p>环境类 + 策略\n例子：</p>\n<ol>\n<li>V8 排序算法</li>\n<li>验证器</li>\n</ol>","frontmatter":{"date":"February 02, 2021","path":"/frontend-design-pattern","title":"前端设计模式"}}},"pageContext":{"id":"03587f16-fad4-502c-89e8-c442d48e2d31"}},"staticQueryHashes":[],"slicesMap":{}}