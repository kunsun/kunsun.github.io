{"componentChunkName":"component---src-templates-blog-post-js","path":"/tree-shaking/","result":{"data":{"site":{"siteMetadata":{"title":"kunsun"}},"markdownRemark":{"html":"<p>uglify 擦除无用代码</p>\n<h2>概念</h2>\n<p>去掉 dead code\nDCE dead code elimination</p>\n<ol>\n<li>代码不会被执行</li>\n<li>代码执行的结果不会被用到</li>\n<li>代码只会影响死变量</li>\n</ol>\n<h2>webpack 配置</h2>\n<p>webpack4 的 mode 设置为 production 自动开启 tree-shaking</p>\n<h2>原理</h2>\n<p>利用 ES6 模块化，ES6 模块的特点：</p>\n<ol>\n<li>import 只能在顶层出现</li>\n<li>import 后就不可以修改</li>\n</ol>\n<h2>注意点</h2>\n<p>代码不能有副作用，不然 tree shaking 会失效</p>\n<ol>\n<li>必须使用 ES6 语法</li>\n</ol>\n<h2>ES 模块化为什么要设计成静态的</h2>\n<p>一个明显的优势是：通过静态分析，我们能够分析出导入的依赖。如果导入的模块没有被使用，我们便可以通过 tree shaking 等手段减少代码体积，进而提升运行性能。这就是基于 ESM 实现 tree shaking 的基础。</p>\n<h2>ES 模块化的静态性带来了限制：</h2>\n<p>只能在文件顶部 import 依赖\nexport 导出的变量类型严格限制\n变量不允许被重新绑定，import 的模块名只能是字符串常量，即不可以动态确定依赖</p>\n<p>我们可以通过作用域分析，分析出代码里变量所属的作用域以及它们之间的引用关系，进而可以推导出变量和导入依赖变量的引用关系，在没有明显引用时，就可以进行去冗余。</p>","frontmatter":{"date":"February 02, 2021","path":"/tree-shaking","title":"Tree Shaking"}}},"pageContext":{"id":"50c97e94-77e2-531d-a79e-681a69ba9ede"}},"staticQueryHashes":[],"slicesMap":{}}