{"componentChunkName":"component---src-templates-blog-post-js","path":"/frontend_algorime/","result":{"data":{"site":{"siteMetadata":{"title":"kunsun"}},"markdownRemark":{"html":"<h2>尾递归</h2>\n<h2>洗牌算法</h2>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">Array.prototype.shuffle = function () {\n  let arr = this\n  let length = arr.length\n  while (length) {\n    let random = Math.floor(Math.random() * length--)\n    console.log(length)\n    let temp = arr[length]\n    arr[length] = arr[random]\n    arr[random] = temp\n  }\n  return arr\n}</code>\n        </deckgo-highlight-code>\n<h2>快速排序</h2>\n<ol>\n<li>初级实现：</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">var arr = [1, 5, 4, 3, 2]\nfunction quickSort(arr) {\n  const len = arr.length\n  console.log(len)\n  if (len &lt;= 1) {\n    return arr.slice()\n  }\n  let leftArr = []\n  let rightArr = []\n  let middleArr = []\n  for (let i = 0; i &lt; len; i++) {\n    if (arr[i] &lt; arr[len - 1]) {\n      leftArr.push(arr[i])\n    } else if (arr[i] === arr[len - 1]) {\n      middleArr.push(arr[i])\n    } else {\n      rightArr.push(arr[i])\n    }\n  }\n  return quickSort(leftArr).concat(middleArr, quickSort(rightArr))\n}\nquickSort(arr)</code>\n        </deckgo-highlight-code>\n<ol start=\"2\">\n<li>在原数组中操作：</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">var arr = [4, 1, 5, 3, 2]\nvar arr1 = [2, 1, 4, 3, 5]\nconst quickSort = (array, start, end) =&gt; {\n  start = start === undefined ? 0 : start\n  end = end === undefined ? arr.length - 1 : end\n  if (start &gt;= end) {\n    return\n  }\n  let value = array[start]\n  let i = start\n  let j = end\n  while (i &lt; j) {\n    // 找出右边第一个小于参照数的下标并记录\n    while (i &lt; j &amp;&amp; array[j] &gt;= value) {\n      j--\n    }\n\n    if (i &lt; j) {\n      arr[i++] = arr[j]\n    }\n\n    // 找出左边第一个大于参照数的下标，并记录\n    while (i &lt; j &amp;&amp; array[i] &lt; value) {\n      i++\n    }\n\n    if (i &lt; j) {\n      arr[j--] = arr[i]\n    }\n  }\n\n  arr[i] = value\n\n  quickSort(array, start, i - 1)\n  quickSort(array, i + 1, end)\n}</code>\n        </deckgo-highlight-code>\n<h2>插入排序</h2>\n<ol>\n<li>简单的实现</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">var arr = [2, 1, 4, 3, 5]\nfunction insertSort(array) {\n  const len = array.length\n  // 定义有序数组最后一个索引；\n  let preIndex\n  // 定义无序数组第一个值；\n  let current\n  for (let i = 1; i &lt; len; i++) {\n    preIndex = i - 1\n    current = arr[i]\n    // 插入操作\n    while (preIndex &gt;= 0 &amp;&amp; current &lt; arr[preIndex]) {\n      array[preIndex + 1] = array[preIndex]\n      preIndex--\n    }\n    array[preIndex + 1] = current\n  }\n  return array\n}\ninsertSort(arr)</code>\n        </deckgo-highlight-code>\n<ol start=\"2\">\n<li>使用 reduce 实现</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">const insertSort = (array) =&gt; array.reduce(insert, [])\nconst insert = (sortedArray, value) =&gt; {\n  const len = sortedArray.length\n  let j = len - 1\n  while (j &gt;= 0 &amp;&amp; sortedArray[j] &gt; value) {\n    sortedArray[j + 1] = sortedArray[j]\n    j--\n  }\n  sortedArray[j + 1] = value\n  return sortedArray\n}\ninsertSort([2, 4, 3, 1])</code>\n        </deckgo-highlight-code>\n<h2>二分查找</h2>\n<p>二分查找插入法</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">const insert = (sortedArray, value) =&gt; {\n  const length = sortedArray.length\n  if (length === 0) {\n    sortedArray.push(value)\n    return sortedArray\n  }\n  let i = 0\n  let j = length\n  let mid\n  if (value &lt; sortedArray[0]) {\n    return sortedArray.unshift(value), sortedArray\n  }\n  if (value &gt;= sortedArray[length - 1]) {\n    return sortedArray.push(value), sortedArray\n  }\n  // 开始二分查找\n  while (i &lt; j) {\n    mid = ((i + j) / 2) | 0\n    if (i === mid) {\n      break\n    }\n    if (value &lt; sortedArray[mid]) {\n      j = mid\n    }\n    if (value &gt; sortedArray[mid]) {\n      i = mid\n    }\n  }\n  let midArray = [value]\n  let lastArray = sortedArray.slice(i + 1)\n  sortedArray = sortedArray\n    .slice(0, i + 1)\n    .concat(midArray)\n    .concat(lastArray)\n  return sortedArray\n}</code>\n        </deckgo-highlight-code>\n<h2>Timsort 实现</h2>\n<p>结合归并排序与插入排序</p>\n<h2>交换星号</h2>\n<p>题目：一个字符串中只包含 _ 和数字，请把 _ 号都放开头。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">;[&quot;*&quot;, 1, 2, &quot;*&quot;].reduce((arr, value) =&gt; {\n  const length = arr.length\n  let i = 0\n  if (value === &quot;*&quot;) {\n    while (i &lt; length) {\n      if (arr[i] != &quot;*&quot;) {\n        break\n      }\n      i++\n    }\n    let lastArr = arr.slice(i)\n    return arr.slice(0, i).concat([&quot;*&quot;]).concat(lastArr)\n  } else {\n    arr.push(value)\n    return arr\n  }\n}, [])</code>\n        </deckgo-highlight-code>\n<h2>最长不重复子串</h2>\n<ol>\n<li>暴力解法</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">var str1 = &quot;abcabcbb&quot;\n\nfunction getLongestStr(str) {\n  const len = str.length\n  let start = 0\n  let end = 1\n  // let subStr = &#39;&#39;;\n  let max = 0\n  for (let i = 0; i &lt; len; i++) {\n    let subStr = &quot;&quot;\n    for (let j = i; j &lt; len; j++) {\n      if (subStr.indexOf(str[j]) === -1) {\n        subStr += str[j]\n        console.log(subStr)\n      } else {\n        max = subStr.length &gt; max ? subStr.length : max\n        break\n      }\n    }\n  }\n  return max\n}\ngetLongestStr(str1)</code>\n        </deckgo-highlight-code>\n<ol start=\"2\">\n<li>滑动窗口解法，保证窗口[i..j]之间没有重复字符</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">let str1 = &quot;acdafbfsifaadcsacddeac&quot;\nfunction getLongestSubstr(str) {\n  let obj = {}\n  let result = 0\n  let len = str.length\n  for (let i = 0, j = 0; ; i++) {\n    // 获取窗口的结束位置\n    while (j &lt; len &amp;&amp; !obj[str[j]]) {\n      obj[str[j++]] = true\n    }\n    // 得到子串的长度\n    result = Math.max(result, j - i)\n    // 循环结束\n    if (j &gt;= len) {\n      console.log(i, j)\n      break\n    }\n    // 获取窗口的开始位置\n    while (str[i] != str[j]) {\n      obj[str[i++]] = false\n    }\n    obj[str[i]] = false\n  }\n  console.log(obj)\n  return result\n}\ngetLongestSubstr(str1)</code>\n        </deckgo-highlight-code>\n<h2>爬楼梯算法</h2>\n<p>题目：假设我们需要爬一个楼梯，这个楼梯一共有 N 阶，可以一步跨越 1 个或者 2 个台阶，那么爬完楼梯一共有多少种方式？</p>\n<ol>\n<li>普通递归解法</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">let num = 10\nfunction getSteps(n) {\n  if (n === 1) return 1\n  if (n === 2) return 2\n  return getSteps(n - 1) + getSteps(n - 2)\n}\ngetSteps(num)</code>\n        </deckgo-highlight-code>\n<ol start=\"2\">\n<li>优化递归解法</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">let num = 10\nfunction getSteps(n) {\n  let arr = []\n  const step = (n) =&gt; {\n    if (n === 1) return 1\n    if (n === 2) return 2\n    if (arr[n] &gt; 0) return arr[n]\n    arr[n] = step(n - 1) + step(n - 2)\n    return arr[n]\n  }\n  return step(n)\n}\ngetSteps(num)</code>\n        </deckgo-highlight-code>\n<h2>所有数相加（回溯算法）</h2>\n<p>题目：给定一组不含重复数字的非负数组和一个非负目标数字，在数组中找出所有数加起来等于给定的目标数字的组合。</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">const array = [2, 3, 6, 7]\nconst target = 7\nconst find = (array, target) =&gt; {\n  // 结果数组\n  let result = []\n  // 深度优先遍历,数组索引,目标和,临时数组\n  const dfs = (index, sum, tmpArray) =&gt; {\n    if (sum === target) {\n      result.push(tmpArray.slice())\n    }\n    // 如果大于,则直接返回\n    if (sum &gt; target) {\n      return\n    }\n    // 这里是关键代码\n    for (let i = index; i &lt; array.length; i++) {\n      tmpArray.push(array[i])\n      dfs(i, sum + array[i], tmpArray)\n      tmpArray.pop()\n    }\n  }\n  dfs(0, 0, [])\n  return result\n}</code>\n        </deckgo-highlight-code>\n<p>高级解法：</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">var combinationSum = function (\n  candidates,\n  target,\n  finalArr = [],\n  currArr = [],\n  startFrom = 0\n) {\n  if (target &lt; 0) {\n    return finalArr\n  }\n  if (target === 0) {\n    finalArr.push(currArr.slice())\n    return finalArr\n  }\n  for (let i = startFrom; i &lt; candidates.length; i++) {\n    const currCandidate = candidates[i]\n    currArr.push(currCandidate)\n    combinationSum(candidates, target - currCandidate, finalArr, currArr, i)\n    currArr.pop()\n  }\n  return finalArr\n}</code>\n        </deckgo-highlight-code>\n<h2>深度遍历</h2>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">function bfs(node) {\n  var queue = []\n  let result = []\n  queue.push(node)\n  while (queue.length) {\n    var item = queue.shift()\n    result.push(item.value)\n    item.left &amp;&amp; queue.push(item.left)\n    item.right &amp;&amp; queue.push(item.right)\n  }\n  return result\n}\nvar node = {\n  value: 0,\n  left: { value: 1, left: { value: 3 }, right: { value: 4 } },\n  right: { value: 2 },\n}\nconsole.log(bfs(node))</code>\n        </deckgo-highlight-code>\n<h2>从一个数组中找出 N 个数，其和为 M 的所有可能。</h2>\n<p>讲解文章：<a href=\"https://juejin.im/post/5c81fee66fb9a049b82b4128\">https://juejin.im/post/5c81fee66fb9a049b82b4128</a></p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">const find = (array, target, sum) =&gt; {\n  const len = array.length\n  let result = []\n\n  for (let i = 0; i &lt; Math.pow(2, len); i++) {\n    if (getCount(i) == target) {\n      let s = 0\n      let temp = []\n      for (let j = 0; j &lt; len; j++) {\n        if (i &amp; (1 &lt;&lt; (len - 1 - j))) {\n          s += array[j]\n          temp.push(array[j])\n        }\n      }\n      if (s == sum) {\n        result.push(temp)\n      }\n    }\n  }\n  return result\n}\n\nfunction getCount(i) {\n  let count = 0\n  while (i) {\n    if (i &amp; 1) {\n      ++count\n    }\n    i &gt;&gt;= 1\n  }\n  return count\n}\n\nconst result = find([1, 2, 3, 4], 2, 4)\nconsole.log(result)</code>\n        </deckgo-highlight-code>\n<h2>有序数组去重，返回去重后数组的新长度</h2>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">let array = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]\nfunction removeDup(arr) {\n  let newArr = []\n  let len = arr.length\n  let result = 0\n  for (let i = 0; i &lt; len - 1; i++) {\n    if (newArr.indexOf(arr[i]) === -1) {\n      result++\n      newArr.push(arr[i])\n    }\n  }\n  console.log(newArr)\n  return result\n}\nremoveDup(array)</code>\n        </deckgo-highlight-code>\n<h2>求数组中的众数</h2>\n<ol>\n<li>普通解法：</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\">let arr = [3, 3, 2]\nfunction getMostNum(arr) {\n  let map = {}\n  for (let i = 0; i &lt; arr.length; i++) {\n    if (!map[arr[i]]) {\n      map[arr[i]] = 1\n    } else {\n      map[arr[i]]++\n    }\n    if ((map[arr[i]] &gt; arr.length / 2) | 0) {\n      return arr[i]\n    }\n  }\n}\ngetMostNum(arr)</code>\n        </deckgo-highlight-code>\n<ol start=\"2\">\n<li>高效解法：</li>\n</ol>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\"  >\n          <code slot=\"code\"></code>\n        </deckgo-highlight-code>","frontmatter":{"date":"February 02, 2021","path":"/frontend_algorime","title":"前端经典算法"}}},"pageContext":{"id":"f69dbae6-2bc3-5e44-876a-c3e6b18f9827"}},"staticQueryHashes":[],"slicesMap":{}}