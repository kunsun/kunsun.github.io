<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/66f30814ff6d7cdf.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/92f44bb82993d879-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/e11418ac562b8ac1-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/3dc4fd6616f3b556.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/cb67a214fed64752.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-115ca99861fb5e3b.js"/><script src="/_next/static/chunks/fd9d1056-058ef2a6fe0734bf.js" async=""></script><script src="/_next/static/chunks/23-9790264ca70f22f0.js" async=""></script><script src="/_next/static/chunks/main-app-ef98807a3a195ea5.js" async=""></script><script src="/_next/static/chunks/291-6bbee38a07e9cada.js" async=""></script><script src="/_next/static/chunks/653-0f61c3cc319dfe42.js" async=""></script><script src="/_next/static/chunks/app/layout-b94baf518cfbd882.js" async=""></script><link rel="icon" href="/favicon.ico" sizes="any"/><title>kunsun.me</title><meta name="description" content="Generated by create next app"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="136x136"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__variable_c1e5c9 __variable_3a0388"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="bg-color border-neutral-100 dark:border-neutral-900 h-max  relative flex justify-between items-center mx-2 px-4 md:px-3 h-[60px]"></div><main class="flex max-w-2xl w-2xl mx-auto bg-gradient"><main class="font-mono"><h1>两数之和</h1><div class="text-[14px] text-tertiary mt-1">2020-07-06</div><div class="markdown mt-10"><p>两数之和是一个最基础的算法，今天由浅入深的分析下这个问题。</p>
<h2>1.0 基础版 普通数组的两数之和</h2>
<p>给定一个整数数组 nums  和一个目标值 target，请你在该数组中找出和为目标值的那   两个   整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<h3>示例:</h3>
<pre><code class="language-log">给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre>
<h3>思路</h3>
<p>第一种思路，典型的双循环，每个元素都与其他元素进行一个组合，找到第一个符合条件的。</p>
<p>第二种思路，一次遍历，使用一个 map 存储，key 为数组的值，value 为索引。当遍历到某个元素时，查看对应的值是否存在，如果存在，则返回。</p>
<h3>解答</h3>
<pre><code class="language-jsx">function twoSum(nums, target) {
  let map = {}
  for (let i = 0; i &lt; nums.length; i++) {
    const key = target - nums[i]
    const element = nums[i]
    if (map[element] === undefined) {
      map[key] = i
    } else {
      return [map[element], i]
    }
  }
}
</code></pre>
<h2>2.0 进阶版，有序数组的两数之和</h2>
<p>给定一个已按照升序排列   的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1  必须小于  index2。</p>
<h3>说明:</h3>
<p>返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>
<h3>示例:</h3>
<pre><code class="language-log">输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
</code></pre>
<h3>思路：</h3>
<p>注意是有序数组，所以可以给定双指针，一个指向头部，一个指向尾部，当指针所指向的元素之和大于 target，则可以移动大元素的指针向前，反之移动小元素的指针向后，直到和为 target。</p>
<h3>解答：</h3>
<pre><code class="language-jsx">var twoSum = function (numbers, target) {
  let len = numbers.length
  let start = 0
  let end = len - 1
  while (start &lt; end) {
    if (numbers[start] + numbers[end] &gt; target) {
      end = end - 1
    } else if (numbers[start] + numbers[end] &lt; target) {
      start = start + 1
    } else {
      return [start + 1, end + 1]
    }
  }
}
</code></pre>
<h2>3.0 两数之和 III - 数据结构设计</h2>
<p>本题属于 leetcode 会员才能看的，是一个类的设计题，以后要是成为 leetcode 会员再来补上。</p>
<h2>4.0 终极版 BST 的两数之和</h2>
<p>给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p>
<p>案例 1:</p>
<p>输入:</p>
<pre><code class="language-log">    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

输出: True
</code></pre>
<p>案例 2:</p>
<pre><code class="language-log">输入:
    5
   / \
  3   6
 / \   \
2   4   7

Target = 28

输出: False
</code></pre>
<h3>思路</h3>
<p>BST 搜索二叉树的特点就是中序遍历后会得到一个有序数组。所以可以先中序遍历，后使用之前的方法。</p>
<h3>解答</h3>
<pre><code class="language-jsx">var findTarget = function (root, k) {
  let arr = []
  var getTree = function (root) {
    if (root) {
      getTree(root.left)
      arr.push(root.val)
      getTree(root.right)
    }
  }
  getTree(root)
  return twoSum(arr, k)
}

var twoSum = function (numbers, target) {
  let len = numbers.length
  let start = 0
  let end = len - 1
  while (start &lt; end) {
    if (numbers[start] + numbers[end] &gt; target) {
      end = end - 1
    } else if (numbers[start] + numbers[end] &lt; target) {
      start = start + 1
    } else {
      return true
    }
  }
  return false
}
</code></pre></div></main></main><script src="/_next/static/chunks/webpack-115ca99861fb5e3b.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/66f30814ff6d7cdf.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/media/92f44bb82993d879-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n3:HL[\"/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n4:HL[\"/_next/static/media/e11418ac562b8ac1-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n5:HL[\"/_next/static/css/3dc4fd6616f3b556.css\",\"style\"]\n6:HL[\"/_next/static/css/cb67a214fed64752.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"7:I[5751,[],\"\"]\na:I[9275,[],\"\"]\nc:I[1343,[],\"\"]\nd:I[9512,[\"291\",\"static/chunks/291-6bbee38a07e9cada.js\",\"653\",\"static/chunks/653-0f61c3cc319dfe42.js\",\"185\",\"static/chunks/app/layout-b94baf518cfbd882.js\"],\"ThemeProvider\"]\ne:I[8871,[\"291\",\"static/chunks/291-6bbee38a07e9cada.js\",\"653\",\"static/chunks/653-0f61c3cc319dfe42.js\",\"185\",\"static/chunks/app/layout-b94baf518cfbd882.js\"],\"default\"]\n10:I[6130,[],\"\"]\nb:[\"slug\",\"two-sum\",\"d\"]\n11:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/3dc4fd6616f3b556.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L7\",null,{\"buildId\":\"0p-ASvtd7DyoEeZE44das\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/blog/two-sum\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"two-sum\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"two-sum\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"two-sum\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L8\",\"$L9\"],null],null]},[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$b\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/cb67a214fed64752.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]]}],null]},[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"suppressHydrationWarning\":true,\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"sizes\":\"any\"}],[\"$\",\"body\",null,{\"className\":\"__variable_c1e5c9 __variable_3a0388\",\"children\":[\"$\",\"$Ld\",null,{\"attribute\":\"class\",\"children\":[[\"$\",\"$Le\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex max-w-2xl w-2xl mx-auto bg-gradient\",\"children\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}]}]]}]}]]}],null],null],\"couldBeIntercepted\":false,\"initialHead\":[false,\"$Lf\"],\"globalErrorComponent\":\"$10\",\"missingSlots\":\"$W11\"}]]\n"])</script><script>self.__next_f.push([1,"f:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"kunsun.me\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Generated by create next app\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"136x136\"}],[\"$\",\"meta\",\"5\",{\"name\":\"next-size-adjust\"}]]\n8:null\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"main\",null,{\"className\":\"font-mono\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"两数之和\"}],[\"$\",\"div\",null,{\"className\":\"text-[14px] text-tertiary mt-1\",\"children\":\"2020-07-06\"}],[\"$\",\"div\",null,{\"className\":\"markdown mt-10\",\"children\":\"$L12\"}]]}]\n"])</script><script>self.__next_f.push([1,"12:[[\"$\",\"p\",null,{\"children\":\"两数之和是一个最基础的算法，今天由浅入深的分析下这个问题。\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"1.0 基础版 普通数组的两数之和\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"给定一个整数数组 nums  和一个目标值 target，请你在该数组中找出和为目标值的那   两个   整数，并返回他们的数组下标。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"示例:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-log\",\"children\":\"给定 nums = [2, 7, 11, 15], target = 9\\n\\n因为 nums[0] + nums[1] = 2 + 7 = 9\\n所以返回 [0, 1]\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"思路\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"第一种思路，典型的双循环，每个元素都与其他元素进行一个组合，找到第一个符合条件的。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"第二种思路，一次遍历，使用一个 map 存储，key 为数组的值，value 为索引。当遍历到某个元素时，查看对应的值是否存在，如果存在，则返回。\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"解答\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-jsx\",\"children\":\"function twoSum(nums, target) {\\n  let map = {}\\n  for (let i = 0; i \u003c nums.length; i++) {\\n    const key = target - nums[i]\\n    const element = nums[i]\\n    if (map[element] === undefined) {\\n      map[key] = i\\n    } else {\\n      return [map[element], i]\\n    }\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"2.0 进阶版，有序数组的两数之和\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"给定一个已按照升序排列   的有序数组，找到两个数使得它们相加之和等于目标数。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"函数应该返回这两个下标值 index1 和 index2，其中 index1  必须小于  index2。\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"说明:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"返回的下标值（index1 和 index2）不是从零开始的。\\n你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"示例:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-log\",\"children\":\"输入: numbers = [2, 7, 11, 15], target = 9\\n输出: [1,2]\\n解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"思路：\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"注意是有序数组，所以可以给定双指针，一个指向头部，一个指向尾部，当指针所指向的元素之和大于 target，则可以移动大元素的指针向前，反之移动小元素的指针向后，直到和为 target。\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"解答：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-jsx\",\"children\":\"var twoSum = function (numbers, target) {\\n  let len = numbers.length\\n  let start = 0\\n  let end = len - 1\\n  while (start \u003c end) {\\n    if (numbers[start] + numbers[end] \u003e target) {\\n      end = end - 1\\n    } else if (numbers[start] + numbers[end] \u003c target) {\\n      start = start + 1\\n    } else {\\n      return [start + 1, end + 1]\\n    }\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"3.0 两数之和 III - 数据结构设计\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"本题属于 leetcode 会员才能看的，是一个类的设计题，以后要是成为 leetcode 会员再来补上。\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"4.0 终极版 BST 的两数之和\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"案例 1:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"输入:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-log\",\"children\":\"    5\\n   / \\\\\\n  3   6\\n / \\\\   \\\\\\n2   4   7\\n\\nTarget = 9\\n\\n输出: True\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"案例 2:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-log\",\"children\":\"输入:\\n    5\\n   / \\\\\\n  3   6\\n / \\\\   \\\\\\n2   4   7\\n\\nTarget = 28\\n\\n输出: False\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"思路\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"BST 搜索二叉树的特点就是中序遍历后会得到一个有序数组。所以可以先中序遍历，后使用之前的方法。\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"解答\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-jsx\",\"children\":\"var findTarget = function (root, k) {\\n  let arr = []\\n  var getTree = function (root) {\\n    if (root) {\\n      getTree(root.left)\\n      arr.push(root.val)\\n      getTree(root.right)\\n    }\\n  }\\n  getTree(root)\\n  return twoSum(arr, k)\\n}\\n\\nvar twoSum = function (numbers, target) {\\n  let len = numbers.length\\n  let start = 0\\n  let end = len - 1\\n  while (start \u003c end) {\\n    if (numbers[start] + numbers[end] \u003e target) {\\n      end = end - 1\\n    } else if (numbers[start] + numbers[end] \u003c target) {\\n      start = start + 1\\n    } else {\\n      return true\\n    }\\n  }\\n  return false\\n}\\n\"}]}]]\n"])</script></body></html>