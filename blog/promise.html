<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/66f30814ff6d7cdf.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/92f44bb82993d879-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/e11418ac562b8ac1-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/14d650bd7f8bf870.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/cb67a214fed64752.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-115ca99861fb5e3b.js"/><script src="/_next/static/chunks/fd9d1056-058ef2a6fe0734bf.js" async=""></script><script src="/_next/static/chunks/23-9790264ca70f22f0.js" async=""></script><script src="/_next/static/chunks/main-app-ef98807a3a195ea5.js" async=""></script><script src="/_next/static/chunks/291-6bbee38a07e9cada.js" async=""></script><script src="/_next/static/chunks/app/layout-3bb9540adf3efcfb.js" async=""></script><title>Create Next App</title><meta name="description" content="Generated by create next app"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__variable_c1e5c9 __variable_3a0388"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="bg-color transition-all border-b border-[0.5px] border-neutral-100 dark:border-neutral-900 sticky h-max top-0 z-[39] "><div class="relative flex justify-between items-center max-w-2xl mx-auto px-5 md:px-3 h-[60px]"></div></div><main class="flex max-w-2xl mx-auto bg-gradient"><main class="font-mono"><h1>Promise</h1><div class="text-[14px] text-tertiary mt-1">2021-02-02</div><div class="markdown mt-10"><p>Promise 构造函数返回一个 promise 对象实例，这个返回的 promise 具有 then 方法。then 方法中，调用者可以定义两个参数，分别是 onfulfilled 和 onrejected，他们都是函数类型。
其中 onfulfilled 通过参数可以获取 promise 对象的 resolved 的值；onrejected 获得 promise 对象 rejected 的值。通过这个值，我们来处理异步完成后的逻辑。
通过这个值，处理异步完成后的逻辑。</p>
<h2>第一步</h2>
<p>建立结构</p>
<pre><code class="language-javascript">function Promise(executor) {}
Promise.prototype.then = function (onfulfilled, onrejected) {}
</code></pre>
<h2>第二步</h2>
<p>完善基本框架</p>
<pre><code class="language-js">function Promise(executor) {
  const self = this
  this.status = &quot;pending&quot;
  this.value = null
  this.reason = null

  function resolve(value) {
    self.value = value
  }

  function reject(value) {
    self.reason = reason
  }

  executor(resolve, reject)
}

Promise.prototype.then = function (
  onfulfilled = Function.prototype,
  onrejected = Function.prototype
) {
  onfulfilled(this.value)
  onrejected(this.reason)
}
</code></pre>
<h2>第三步</h2>
<p>加入异步逻辑：在合适的时候再执行 resolve</p>
<pre><code class="language-js">function Promise(executor) {
  this.status = &quot;pending&quot;
  this.value = null
  this.reason = null
  this.onFulfilledFunc = Function.prototype
  this.onRejectedFunc = Function.prototype

  // 自己的resolve函数，由调用者触发
  const resolve = (value) =&gt; {
    if (value instanceof Promise) {
      return value.then(resolve, reject)
    }
    setTimeout(() =&gt; {
      if (this.status === &quot;pending&quot;) {
        this.value = value
        this.status = &quot;fulfilled&quot;
        this.onFulfilledFunc(this.value)
      }
    })
  }
  // 自己的reject函数，由调用者触发
  const reject = (reason) =&gt; {
    setTimeout(() =&gt; {
      if (this.status === &quot;pending&quot;) {
        this.reason = reason
        this.status = &quot;rejected&quot;
        this.onRejectedFunc(this.reason)
      }
    })
  }
  // 调用时执行，参数是自己定义的reject与resolve
  // 立即执行
  executor(resolve, reject)
}

Promise.prototype.then = function (onfulfilled, onreject) {
  onfulfilled = typeof onfulfilled === &quot;function&quot; ? onfulfilled : (data) =&gt; data
  onrejected =
    typeof onrejected === &quot;function&quot;
      ? onrejected
      : (error) =&gt; {
          throw error
        }

  if (this.status === &quot;fulfilled&quot;) {
    onfulfilled(this.value)
  }

  if (this.status === &quot;rejected&quot;) {
    onrejected(this.value)
  }

  if (this.status === &quot;pending&quot;) {
    this.onFulfilledFunc = onfulfilled
    this.onRejectedFunc = onrejected
  }
}

// 调用Promise，executor
let promise = new Promise((resolve, reject) =&gt; {
  resolve(&quot;data&quot;)
  setTimeout(() =&gt; {
    resolve(&quot;data&quot;)
  }, 2000)
})

promise.then((data) =&gt; {
  console.log(data)
})
console.log(1)
</code></pre>
<h2>第四步：加入任务队列逻辑</h2>
<p>使用 setTimeout 模拟</p>
<h2>第五步：细节优化</h2>
<ol>
<li>抛出错误</li>
<li>将 onFulfilledFunc 存入数组</li>
</ol>
<pre><code class="language-javascript">function Promise(executor) {
  this.status = &quot;pending&quot;
  this.value = null
  this.reason = null
  this.onRejectedArr = []
  this.onFulfilledArr = []

  const resolve = (value) =&gt; {
    if (value instanceof Promise) {
      return value.then(resolve, reject)
    }
    setTimeout(() =&gt; {
      if (this.status === &quot;pending&quot;) {
        this.value = value
        this.status = &quot;fulfilled&quot;
        this.onFulfilledArr.forEach((func) =&gt; {
          func(value)
        })
      }
    })
  }

  const reject = (reason) =&gt; {
    setTimeout(() =&gt; {
      if (this.status === &quot;pending&quot;) {
        this.reason = reason
        this.status = &quot;rejected&quot;
        this.onRejectedArr.forEach((func) =&gt; {
          func(reason)
        })
      }
    })
  }

  try {
    executor(resolve, reject)
  } catch (e) {
    reject(e)
  }
}

Promise.prototype.then = function (onfulfilled, onrejected) {
  onfulfilled = typeof onfulfilled === &quot;function&quot; ? onfulfilled : (data) =&gt; data
  onrejected =
    typeof onrejected === &quot;function&quot;
      ? onrejected
      : (error) =&gt; {
          throw error
        }
  if (this.status === &quot;fulfilled&quot;) {
    onfulfilled(this.value)
  }

  if (this.status === &quot;rejected&quot;) {
    onrejected(this.value)
  }
  if (this.status === &quot;pending&quot;) {
    this.onFulfilledArr.push(onfulfilled)
    this.onRejectedArr.push(onrejected)
  }
}
</code></pre>
<h2>第六步：链式调用</h2>
<p>一个 Promise 实例的 then 方法体 onfulfilled 函数和 onrejected 函数中，是支持再次返回一个 Promise 实例的，也支持返回非 Promise 的普通值。
修改 Promise.prototype.then:</p>
<pre><code class="language-js">Promise.prototype.then = function (onfulfilled, onrejected) {
  onfulfilled = typeof onfulfilled === &quot;function&quot; ? onfulfilled : (data) =&gt; data
  onrejected =
    typeof onrejected === &quot;function&quot;
      ? onrejected
      : (error) =&gt; {
          throw error
        }
  let promise2
  if (this.status === &quot;fulfilled&quot;) {
    return (promise2 = new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        try {
          let result = onfulfilled(this.value)
          resolve(result)
        } catch (e) {
          reject(e)
        }
      })
    }))
  }
  if (this.status === &quot;rejected&quot;) {
    return (promise2 = new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        try {
          let result = onrejected(this.reason)
          reject(result)
        } catch (e) {
          reject(e)
        }
      })
    }))
  }
  if (this.status === &quot;pending&quot;) {
    return (promise2 = new Promise((resolve, reject) =&gt; {
      this.onFulfilledArray.push(() =&gt; {
        setTimeout(() =&gt; {
          try {
            let result = onfulfilled(this.value)
            resolve(result)
          } catch (e) {
            reject(e)
          }
        })
      })
      this.onRejectedArr.push(() =&gt; {
        setTimeout(() =&gt; {
          try {
            let result = onrejected(this.reason)
            resolve(result)
          } catch (e) {
            reject(e)
          }
        })
      })
    }))
  }
}
</code></pre>
<h2>第七步：完善链式调用</h2>
<p>这里的逻辑有些复杂</p>
<h2>第八步：Promise 穿透实现</h2>
<p>如果 then 传入的 onfulfilled 与 onrejected 不为函数，则使用默认值</p>
<pre><code class="language-javascript">const promise = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&quot;kunsun&quot;)
  }, 2000)
})
promise.then(null).then((data) =&gt; {
  console.log(data)
})
</code></pre>
<h2>第九步：Promise 静态方法与其他方法实现</h2>
<h3>Promise.prototype.catch</h3>
<pre><code class="language-js">Promise.prototype.catch = function (catchFunc) {
  return this.then(null, catchFunc)
}
</code></pre>
<h3>Promise.resolve</h3>
<pre><code class="language-js">Promise.resolve = function (value) {
  return new Promise((resolve, reject) =&gt; {
    resolve(value)
  })
}
</code></pre>
<h3>Promise.reject</h3>
<pre><code class="language-js">Promise.reject = function (value) {
  return new Promise((resolve, reject) =&gt; {
    reject(value)
  })
}
</code></pre>
<h3>Promise.all</h3>
<blockquote>
<p>Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都完成时才 resolve。如果参数中 promise 有一个失败（rejected）,此实例失败，失败原因是第一个失败 promise 的结果。</p>
</blockquote>
<pre><code class="language-javascript">Promise.all = function (promiseArr) {
  if (!Array.isArray(promiseArr)) {
    throw new Error(&quot;参数不是数组&quot;)
  }
  return new Promise((resolve, reject) =&gt; {
    try {
      let resolveArr = []
      const length = promiseArr.length
      for (let i = 0; i &lt; length; i++) {
        promiseArr[i].then((data) =&gt; {
          resolveArr.push(data)
          if (resolveArr.length === length) {
            resolve(resolveArr)
          }
        }, reject)
      }
    } catch (e) {
      reject(e)
    }
  })
}
</code></pre>
<h3>Promise.race</h3>
<blockquote>
<p>当 iterable 参数里任何一个成功或失败，直接返回</p>
</blockquote>
<pre><code class="language-js">Promise.race = function (promiseArr) {
  if (!Array.isArray(promiseArr)) {
    throw new Error(&quot;参数不是数组&quot;)
  }
  return new Promise((resolve, reject) =&gt; {
    try {
      const length = primiseArr.length
      for (let i = 0; i &lt; length; i++) {
        promiseArray[i].then(resolve, reject)
      }
    } catch (e) {
      reject(e)
    }
  })
}
</code></pre>
<h2>最终代码</h2>
<pre><code class="language-javascript">function Promise(executor) {
  this.status = &quot;pending&quot;
  this.value = null
  this.reason = null
  this.onFulfilledArray = []
  this.onRejectedArray = []

  const resolve = (value) =&gt; {
    if (value instanceof Promise) {
      return value.then(resolve, reject)
    }
    setTimeout(() =&gt; {
      if (this.status === &quot;pending&quot;) {
        this.value = value
        this.status = &quot;fulfilled&quot;

        this.onFulfilledArray.forEach((func) =&gt; {
          func(value)
        })
      }
    })
  }

  const reject = (reason) =&gt; {
    setTimeout(() =&gt; {
      if (this.status === &quot;pending&quot;) {
        this.reason = reason
        this.status = &quot;rejected&quot;

        this.onRejectedArray.forEach((func) =&gt; {
          func(reason)
        })
      }
    })
  }

  try {
    executor(resolve, reject)
  } catch (e) {
    reject(e)
  }
}

const resolvePromise = (promise2, result, resolve, reject) =&gt; {
  // 当 result 和 promise2 相等时，也就是说 onfulfilled 返回 promise2 时，进行 reject
  if (result === promise2) {
    return reject(new TypeError(&quot;error due to circular reference&quot;))
  }

  // 是否已经执行过 onfulfilled 或者 onrejected
  let consumed = false
  let thenable

  if (result instanceof Promise) {
    if (result.status === &quot;pending&quot;) {
      result.then(function (data) {
        resolvePromise(promise2, data, resolve, reject)
      }, reject)
    } else {
      result.then(resolve, reject)
    }
    return
  }

  let isComplexResult = (target) =&gt;
    (typeof target === &quot;function&quot; || typeof target === &quot;object&quot;) &amp;&amp;
    target !== null
  // 如果返回的是疑似 Promise 类型
  if (isComplexResult(result)) {
    try {
      thenable = result.then
      // 如果返回的是 Promise 类型，具有 then 方法
      if (typeof thenable === &quot;function&quot;) {
        thenable.call(
          result,
          function (data) {
            if (consumed) {
              return
            }
            consumed = true

            return resolvePromise(promise2, data, resolve, reject)
          },
          function (error) {
            if (consumed) {
              return
            }
            consumed = true

            return reject(error)
          }
        )
      } else {
        return resolve(result)
      }
    } catch (e) {
      if (consumed) {
        return
      }
      consumed = true
      return reject(e)
    }
  } else {
    return resolve(result)
  }
}

Promise.prototype.then = function (onfulfilled, onrejected) {
  onfulfilled = typeof onfulfilled === &quot;function&quot; ? onfulfilled : (data) =&gt; data
  onrejected =
    typeof onrejected === &quot;function&quot;
      ? onrejected
      : (error) =&gt; {
          throw error
        }

  // promise2 将作为 then 方法的返回值
  let promise2

  if (this.status === &quot;fulfilled&quot;) {
    return (promise2 = new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        try {
          // 这个新的 promise2 resolved 的值为 onfulfilled 的执行结果
          let result = onfulfilled(this.value)
          resolvePromise(promise2, result, resolve, reject)
        } catch (e) {
          reject(e)
        }
      })
    }))
  }
  if (this.status === &quot;rejected&quot;) {
    return (promise2 = new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        try {
          // 这个新的 promise2 reject 的值为 onrejected 的执行结果
          let result = onrejected(this.reason)
          resolvePromise(promise2, result, resolve, reject)
        } catch (e) {
          reject(e)
        }
      })
    }))
  }
  if (this.status === &quot;pending&quot;) {
    return (promise2 = new Promise((resolve, reject) =&gt; {
      this.onFulfilledArray.push((value) =&gt; {
        try {
          let result = onfulfilled(value)
          resolvePromise(promise2, result, resolve, reject)
        } catch (e) {
          return reject(e)
        }
      })

      this.onRejectedArray.push((reason) =&gt; {
        try {
          let result = onrejected(reason)
          resolvePromise(promise2, result, resolve, reject)
        } catch (e) {
          return reject(e)
        }
      })
    }))
  }
}

Promise.prototype.catch = function (catchFunc) {
  return this.then(null, catchFunc)
}

Promise.resolve = function (value) {
  return new Promise((resolve, reject) =&gt; {
    resolve(value)
  })
}

Promise.reject = function (value) {
  return new Promise((resolve, reject) =&gt; {
    reject(value)
  })
}

Promise.race = function (promiseArray) {
  if (!Array.isArray(promiseArray)) {
    throw new TypeError(&quot;The arguments should be an array!&quot;)
  }
  return new Promise((resolve, reject) =&gt; {
    try {
      const length = promiseArray.length
      for (let i = 0; i &lt; length; i++) {
        promiseArray[i].then(resolve, reject)
      }
    } catch (e) {
      reject(e)
    }
  })
}

Promise.all = function (promiseArray) {
  if (!Array.isArray(promiseArray)) {
    throw new TypeError(&quot;The arguments should be an array!&quot;)
  }
  return new Promise((resolve, reject) =&gt; {
    try {
      let resultArray = []

      const length = promiseArray.length

      for (let i = 0; i &lt; length; i++) {
        promiseArray[i].then((data) =&gt; {
          resultArray.push(data)

          if (resultArray.length === length) {
            resolve(resultArray)
          }
        }, reject)
      }
    } catch (e) {
      reject(e)
    }
  })
}
</code></pre>
<h2>总结</h2>
<ol>
<li>Promise 可以保持某个 pending 一段时间</li>
<li>Promise 需要处理错误</li>
<li>Promise 实例添加多个 then</li>
<li>链式调用</li>
<li>Promise 穿透</li>
<li>静态方法</li>
</ol></div></main></main><script src="/_next/static/chunks/webpack-115ca99861fb5e3b.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/66f30814ff6d7cdf.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/media/92f44bb82993d879-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n3:HL[\"/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n4:HL[\"/_next/static/media/e11418ac562b8ac1-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n5:HL[\"/_next/static/css/14d650bd7f8bf870.css\",\"style\"]\n6:HL[\"/_next/static/css/cb67a214fed64752.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"7:I[5751,[],\"\"]\na:I[9275,[],\"\"]\nc:I[1343,[],\"\"]\nd:I[9512,[\"291\",\"static/chunks/291-6bbee38a07e9cada.js\",\"185\",\"static/chunks/app/layout-3bb9540adf3efcfb.js\"],\"ThemeProvider\"]\ne:I[8871,[\"291\",\"static/chunks/291-6bbee38a07e9cada.js\",\"185\",\"static/chunks/app/layout-3bb9540adf3efcfb.js\"],\"default\"]\n10:I[6130,[],\"\"]\nb:[\"slug\",\"promise\",\"d\"]\n11:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/14d650bd7f8bf870.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L7\",null,{\"buildId\":\"H_a7jOF6IzhXIsp_5oCtQ\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/blog/promise\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"promise\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"promise\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"promise\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L8\",\"$L9\"],null],null]},[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$b\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/cb67a214fed64752.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]]}],null]},[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"suppressHydrationWarning\":true,\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_c1e5c9 __variable_3a0388\",\"children\":[\"$\",\"$Ld\",null,{\"attribute\":\"class\",\"children\":[[\"$\",\"$Le\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex max-w-2xl mx-auto bg-gradient\",\"children\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}]}]]}]}]}],null],null],\"couldBeIntercepted\":false,\"initialHead\":[false,\"$Lf\"],\"globalErrorComponent\":\"$10\",\"missingSlots\":\"$W11\"}]]\n"])</script><script>self.__next_f.push([1,"f:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Create Next App\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Generated by create next app\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"5\",{\"name\":\"next-size-adjust\"}]]\n8:null\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"main\",null,{\"className\":\"font-mono\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"Promise\"}],[\"$\",\"div\",null,{\"className\":\"text-[14px] text-tertiary mt-1\",\"children\":\"2021-02-02\"}],[\"$\",\"div\",null,{\"className\":\"markdown mt-10\",\"children\":\"$L12\"}]]}]\n"])</script><script>self.__next_f.push([1,"13:T66a,function Promise(executor) {\n  this.status = \"pending\"\n  this.value = null\n  this.reason = null\n  this.onFulfilledFunc = Function.prototype\n  this.onRejectedFunc = Function.prototype\n\n  // 自己的resolve函数，由调用者触发\n  const resolve = (value) =\u003e {\n    if (value instanceof Promise) {\n      return value.then(resolve, reject)\n    }\n    setTimeout(() =\u003e {\n      if (this.status === \"pending\") {\n        this.value = value\n        this.status = \"fulfilled\"\n        this.onFulfilledFunc(this.value)\n      }\n    })\n  }\n  // 自己的reject函数，由调用者触发\n  const reject = (reason) =\u003e {\n    setTimeout(() =\u003e {\n      if (this.status === \"pending\") {\n        this.reason = reason\n        this.status = \"rejected\"\n        this.onRejectedFunc(this.reason)\n      }\n    })\n  }\n  // 调用时执行，参数是自己定义的reject与resolve\n  // 立即执行\n  executor(resolve, reject)\n}\n\nPromise.prototype.then = function (onfulfilled, onreject) {\n  onfulfilled = typeof onfulfilled === \"function\" ? onfulfilled : (data) =\u003e data\n  onrejected =\n    typeof onrejected === \"function\"\n      ? onrejected\n      : (error) =\u003e {\n          throw error\n        }\n\n  if (this.status === \"fulfilled\") {\n    onfulfilled(this.value)\n  }\n\n  if (this.status === \"rejected\") {\n    onrejected(this.value)\n  }\n\n  if (this.status === \"pending\") {\n    this.onFulfilledFunc = onfulfilled\n    this.onRejectedFunc = onrejected\n  }\n}\n\n// 调用Promise，executor\nlet promise = new Promise((resolve, reject) =\u003e {\n  resolve(\"data\")\n  setTimeout(() =\u003e {\n    resolve(\"data\")\n  }, 2000)\n})\n\npromise.then((data) =\u003e {\n  console.log(data)\n})\nconsole.log(1)\n14:T542,function Promise(executor) {\n  this.status = \"pending\"\n  this.value = null\n  this.reason = null\n  this.onRejectedArr = []\n  this.onFulfilledArr = []\n\n  const resolve = (value) =\u003e {\n    if (value instanceof Promise) {\n      return value.then(resolve, reject)\n    }\n    setTimeout(() =\u003e {\n      if (this.status === \"pending\") {\n        this.value = value\n        this.status = \"fulfilled\"\n   "])</script><script>self.__next_f.push([1,"     this.onFulfilledArr.forEach((func) =\u003e {\n          func(value)\n        })\n      }\n    })\n  }\n\n  const reject = (reason) =\u003e {\n    setTimeout(() =\u003e {\n      if (this.status === \"pending\") {\n        this.reason = reason\n        this.status = \"rejected\"\n        this.onRejectedArr.forEach((func) =\u003e {\n          func(reason)\n        })\n      }\n    })\n  }\n\n  try {\n    executor(resolve, reject)\n  } catch (e) {\n    reject(e)\n  }\n}\n\nPromise.prototype.then = function (onfulfilled, onrejected) {\n  onfulfilled = typeof onfulfilled === \"function\" ? onfulfilled : (data) =\u003e data\n  onrejected =\n    typeof onrejected === \"function\"\n      ? onrejected\n      : (error) =\u003e {\n          throw error\n        }\n  if (this.status === \"fulfilled\") {\n    onfulfilled(this.value)\n  }\n\n  if (this.status === \"rejected\") {\n    onrejected(this.value)\n  }\n  if (this.status === \"pending\") {\n    this.onFulfilledArr.push(onfulfilled)\n    this.onRejectedArr.push(onrejected)\n  }\n}\n15:T58e,Promise.prototype.then = function (onfulfilled, onrejected) {\n  onfulfilled = typeof onfulfilled === \"function\" ? onfulfilled : (data) =\u003e data\n  onrejected =\n    typeof onrejected === \"function\"\n      ? onrejected\n      : (error) =\u003e {\n          throw error\n        }\n  let promise2\n  if (this.status === \"fulfilled\") {\n    return (promise2 = new Promise((resolve, reject) =\u003e {\n      setTimeout(() =\u003e {\n        try {\n          let result = onfulfilled(this.value)\n          resolve(result)\n        } catch (e) {\n          reject(e)\n        }\n      })\n    }))\n  }\n  if (this.status === \"rejected\") {\n    return (promise2 = new Promise((resolve, reject) =\u003e {\n      setTimeout(() =\u003e {\n        try {\n          let result = onrejected(this.reason)\n          reject(result)\n        } catch (e) {\n          reject(e)\n        }\n      })\n    }))\n  }\n  if (this.status === \"pending\") {\n    return (promise2 = new Promise((resolve, reject) =\u003e {\n      this.onFulfilledArray.push(() =\u003e {\n        setTimeout(() =\u003e {\n          try {\n            let result = onfulfilled(this.value)\n            resolv"])</script><script>self.__next_f.push([1,"e(result)\n          } catch (e) {\n            reject(e)\n          }\n        })\n      })\n      this.onRejectedArr.push(() =\u003e {\n        setTimeout(() =\u003e {\n          try {\n            let result = onrejected(this.reason)\n            resolve(result)\n          } catch (e) {\n            reject(e)\n          }\n        })\n      })\n    }))\n  }\n}\n16:T14e3,"])</script><script>self.__next_f.push([1,"function Promise(executor) {\n  this.status = \"pending\"\n  this.value = null\n  this.reason = null\n  this.onFulfilledArray = []\n  this.onRejectedArray = []\n\n  const resolve = (value) =\u003e {\n    if (value instanceof Promise) {\n      return value.then(resolve, reject)\n    }\n    setTimeout(() =\u003e {\n      if (this.status === \"pending\") {\n        this.value = value\n        this.status = \"fulfilled\"\n\n        this.onFulfilledArray.forEach((func) =\u003e {\n          func(value)\n        })\n      }\n    })\n  }\n\n  const reject = (reason) =\u003e {\n    setTimeout(() =\u003e {\n      if (this.status === \"pending\") {\n        this.reason = reason\n        this.status = \"rejected\"\n\n        this.onRejectedArray.forEach((func) =\u003e {\n          func(reason)\n        })\n      }\n    })\n  }\n\n  try {\n    executor(resolve, reject)\n  } catch (e) {\n    reject(e)\n  }\n}\n\nconst resolvePromise = (promise2, result, resolve, reject) =\u003e {\n  // 当 result 和 promise2 相等时，也就是说 onfulfilled 返回 promise2 时，进行 reject\n  if (result === promise2) {\n    return reject(new TypeError(\"error due to circular reference\"))\n  }\n\n  // 是否已经执行过 onfulfilled 或者 onrejected\n  let consumed = false\n  let thenable\n\n  if (result instanceof Promise) {\n    if (result.status === \"pending\") {\n      result.then(function (data) {\n        resolvePromise(promise2, data, resolve, reject)\n      }, reject)\n    } else {\n      result.then(resolve, reject)\n    }\n    return\n  }\n\n  let isComplexResult = (target) =\u003e\n    (typeof target === \"function\" || typeof target === \"object\") \u0026\u0026\n    target !== null\n  // 如果返回的是疑似 Promise 类型\n  if (isComplexResult(result)) {\n    try {\n      thenable = result.then\n      // 如果返回的是 Promise 类型，具有 then 方法\n      if (typeof thenable === \"function\") {\n        thenable.call(\n          result,\n          function (data) {\n            if (consumed) {\n              return\n            }\n            consumed = true\n\n            return resolvePromise(promise2, data, resolve, reject)\n          },\n          function (error) {\n            if (consumed) {\n              return\n            }\n            consumed = true\n\n            return reject(error)\n          }\n        )\n      } else {\n        return resolve(result)\n      }\n    } catch (e) {\n      if (consumed) {\n        return\n      }\n      consumed = true\n      return reject(e)\n    }\n  } else {\n    return resolve(result)\n  }\n}\n\nPromise.prototype.then = function (onfulfilled, onrejected) {\n  onfulfilled = typeof onfulfilled === \"function\" ? onfulfilled : (data) =\u003e data\n  onrejected =\n    typeof onrejected === \"function\"\n      ? onrejected\n      : (error) =\u003e {\n          throw error\n        }\n\n  // promise2 将作为 then 方法的返回值\n  let promise2\n\n  if (this.status === \"fulfilled\") {\n    return (promise2 = new Promise((resolve, reject) =\u003e {\n      setTimeout(() =\u003e {\n        try {\n          // 这个新的 promise2 resolved 的值为 onfulfilled 的执行结果\n          let result = onfulfilled(this.value)\n          resolvePromise(promise2, result, resolve, reject)\n        } catch (e) {\n          reject(e)\n        }\n      })\n    }))\n  }\n  if (this.status === \"rejected\") {\n    return (promise2 = new Promise((resolve, reject) =\u003e {\n      setTimeout(() =\u003e {\n        try {\n          // 这个新的 promise2 reject 的值为 onrejected 的执行结果\n          let result = onrejected(this.reason)\n          resolvePromise(promise2, result, resolve, reject)\n        } catch (e) {\n          reject(e)\n        }\n      })\n    }))\n  }\n  if (this.status === \"pending\") {\n    return (promise2 = new Promise((resolve, reject) =\u003e {\n      this.onFulfilledArray.push((value) =\u003e {\n        try {\n          let result = onfulfilled(value)\n          resolvePromise(promise2, result, resolve, reject)\n        } catch (e) {\n          return reject(e)\n        }\n      })\n\n      this.onRejectedArray.push((reason) =\u003e {\n        try {\n          let result = onrejected(reason)\n          resolvePromise(promise2, result, resolve, reject)\n        } catch (e) {\n          return reject(e)\n        }\n      })\n    }))\n  }\n}\n\nPromise.prototype.catch = function (catchFunc) {\n  return this.then(null, catchFunc)\n}\n\nPromise.resolve = function (value) {\n  return new Promise((resolve, reject) =\u003e {\n    resolve(value)\n  })\n}\n\nPromise.reject = function (value) {\n  return new Promise((resolve, reject) =\u003e {\n    reject(value)\n  })\n}\n\nPromise.race = function (promiseArray) {\n  if (!Array.isArray(promiseArray)) {\n    throw new TypeError(\"The arguments should be an array!\")\n  }\n  return new Promise((resolve, reject) =\u003e {\n    try {\n      const length = promiseArray.length\n      for (let i = 0; i \u003c length; i++) {\n        promiseArray[i].then(resolve, reject)\n      }\n    } catch (e) {\n      reject(e)\n    }\n  })\n}\n\nPromise.all = function (promiseArray) {\n  if (!Array.isArray(promiseArray)) {\n    throw new TypeError(\"The arguments should be an array!\")\n  }\n  return new Promise((resolve, reject) =\u003e {\n    try {\n      let resultArray = []\n\n      const length = promiseArray.length\n\n      for (let i = 0; i \u003c length; i++) {\n        promiseArray[i].then((data) =\u003e {\n          resultArray.push(data)\n\n          if (resultArray.length === length) {\n            resolve(resultArray)\n          }\n        }, reject)\n      }\n    } catch (e) {\n      reject(e)\n    }\n  })\n}\n"])</script><script>self.__next_f.push([1,"12:[[\"$\",\"p\",null,{\"children\":\"Promise 构造函数返回一个 promise 对象实例，这个返回的 promise 具有 then 方法。then 方法中，调用者可以定义两个参数，分别是 onfulfilled 和 onrejected，他们都是函数类型。\\n其中 onfulfilled 通过参数可以获取 promise 对象的 resolved 的值；onrejected 获得 promise 对象 rejected 的值。通过这个值，我们来处理异步完成后的逻辑。\\n通过这个值，处理异步完成后的逻辑。\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"第一步\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"建立结构\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-javascript\",\"children\":\"function Promise(executor) {}\\nPromise.prototype.then = function (onfulfilled, onrejected) {}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"第二步\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"完善基本框架\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function Promise(executor) {\\n  const self = this\\n  this.status = \\\"pending\\\"\\n  this.value = null\\n  this.reason = null\\n\\n  function resolve(value) {\\n    self.value = value\\n  }\\n\\n  function reject(value) {\\n    self.reason = reason\\n  }\\n\\n  executor(resolve, reject)\\n}\\n\\nPromise.prototype.then = function (\\n  onfulfilled = Function.prototype,\\n  onrejected = Function.prototype\\n) {\\n  onfulfilled(this.value)\\n  onrejected(this.reason)\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"第三步\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"加入异步逻辑：在合适的时候再执行 resolve\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"$13\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"第四步：加入任务队列逻辑\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"使用 setTimeout 模拟\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"第五步：细节优化\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"抛出错误\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"将 onFulfilledFunc 存入数组\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-javascript\",\"children\":\"$14\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"第六步：链式调用\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"一个 Promise 实例的 then 方法体 onfulfilled 函数和 onrejected 函数中，是支持再次返回一个 Promise 实例的，也支持返回非 Promise 的普通值。\\n修改 Promise.prototype.then:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"$15\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"第七步：完善链式调用\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"这里的逻辑有些复杂\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"第八步：Promise 穿透实现\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"如果 then 传入的 onfulfilled 与 onrejected 不为函数，则使用默认值\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-javascript\",\"children\":\"const promise = new Promise((resolve, reject) =\u003e {\\n  setTimeout(() =\u003e {\\n    resolve(\\\"kunsun\\\")\\n  }, 2000)\\n})\\npromise.then(null).then((data) =\u003e {\\n  console.log(data)\\n})\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"第九步：Promise 静态方法与其他方法实现\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Promise.prototype.catch\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"Promise.prototype.catch = function (catchFunc) {\\n  return this.then(null, catchFunc)\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Promise.resolve\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"Promise.resolve = function (value) {\\n  return new Promise((resolve, reject) =\u003e {\\n    resolve(value)\\n  })\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Promise.reject\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"Promise.reject = function (value) {\\n  return new Promise((resolve, reject) =\u003e {\\n    reject(value)\\n  })\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Promise.all\"}],\"\\n\",[\"$\",\"blockquote\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都完成时才 resolve。如果参数中 promise 有一个失败（rejected）,此实例失败，失败原因是第一个失败 promise 的结果。\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-javascript\",\"children\":\"Promise.all = function (promiseArr) {\\n  if (!Array.isArray(promiseArr)) {\\n    throw new Error(\\\"参数不是数组\\\")\\n  }\\n  return new Promise((resolve, reject) =\u003e {\\n    try {\\n      let resolveArr = []\\n      const length = promiseArr.length\\n      for (let i = 0; i \u003c length; i++) {\\n        promiseArr[i].then((data) =\u003e {\\n          resolveArr.push(data)\\n          if (resolveArr.length === length) {\\n            resolve(resolveArr)\\n          }\\n        }, reject)\\n      }\\n    } catch (e) {\\n      reject(e)\\n    }\\n  })\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Promise.race\"}],\"\\n\",[\"$\",\"blockquote\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"当 iterable 参数里任何一个成功或失败，直接返回\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"Promise.race = function (promiseArr) {\\n  if (!Array.isArray(promiseArr)) {\\n    throw new Error(\\\"参数不是数组\\\")\\n  }\\n  return new Promise((resolve, reject) =\u003e {\\n    try {\\n      const length = primiseArr.length\\n      for (let i = 0; i \u003c length; i++) {\\n        promiseArray[i].then(resolve, reject)\\n      }\\n    } catch (e) {\\n      reject(e)\\n    }\\n  })\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"最终代码\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-javascript\",\"children\":\"$16\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"总结\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Promise 可以保持某个 pending 一段时间\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Promise 需要处理错误\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Promise 实例添加多个 then\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"链式调用\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Promise 穿透\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"静态方法\"}],\"\\n\"]}]]\n"])</script></body></html>