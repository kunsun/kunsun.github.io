<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/66f30814ff6d7cdf.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/92f44bb82993d879-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/e11418ac562b8ac1-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/3dc4fd6616f3b556.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/cb67a214fed64752.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-115ca99861fb5e3b.js"/><script src="/_next/static/chunks/fd9d1056-058ef2a6fe0734bf.js" async=""></script><script src="/_next/static/chunks/23-9790264ca70f22f0.js" async=""></script><script src="/_next/static/chunks/main-app-ef98807a3a195ea5.js" async=""></script><script src="/_next/static/chunks/291-6bbee38a07e9cada.js" async=""></script><script src="/_next/static/chunks/653-0f61c3cc319dfe42.js" async=""></script><script src="/_next/static/chunks/app/layout-b94baf518cfbd882.js" async=""></script><link rel="icon" href="/favicon.ico" sizes="any"/><title>kunsun.me</title><meta name="description" content="Generated by create next app"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__variable_c1e5c9 __variable_3a0388"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="bg-color border-neutral-100 dark:border-neutral-900 h-max  relative flex justify-between items-center mx-2 px-4 md:px-3 h-[60px]"></div><main class="flex max-w-2xl w-2xl mx-auto bg-gradient"><main class="font-mono"><h1>前端经典算法</h1><div class="text-[14px] text-tertiary mt-1">2021-02-02</div><div class="markdown mt-10"><h2>尾递归</h2>
<h2>洗牌算法</h2>
<pre><code class="language-js">Array.prototype.shuffle = function () {
  let arr = this
  let length = arr.length
  while (length) {
    let random = Math.floor(Math.random() * length--)
    console.log(length)
    let temp = arr[length]
    arr[length] = arr[random]
    arr[random] = temp
  }
  return arr
}
</code></pre>
<h2>快速排序</h2>
<ol>
<li>初级实现：</li>
</ol>
<pre><code class="language-js">var arr = [1, 5, 4, 3, 2]
function quickSort(arr) {
  const len = arr.length
  console.log(len)
  if (len &lt;= 1) {
    return arr.slice()
  }
  let leftArr = []
  let rightArr = []
  let middleArr = []
  for (let i = 0; i &lt; len; i++) {
    if (arr[i] &lt; arr[len - 1]) {
      leftArr.push(arr[i])
    } else if (arr[i] === arr[len - 1]) {
      middleArr.push(arr[i])
    } else {
      rightArr.push(arr[i])
    }
  }
  return quickSort(leftArr).concat(middleArr, quickSort(rightArr))
}
quickSort(arr)
</code></pre>
<ol start="2">
<li>在原数组中操作：</li>
</ol>
<pre><code class="language-js">var arr = [4, 1, 5, 3, 2]
var arr1 = [2, 1, 4, 3, 5]
const quickSort = (array, start, end) =&gt; {
  start = start === undefined ? 0 : start
  end = end === undefined ? arr.length - 1 : end
  if (start &gt;= end) {
    return
  }
  let value = array[start]
  let i = start
  let j = end
  while (i &lt; j) {
    // 找出右边第一个小于参照数的下标并记录
    while (i &lt; j &amp;&amp; array[j] &gt;= value) {
      j--
    }

    if (i &lt; j) {
      arr[i++] = arr[j]
    }

    // 找出左边第一个大于参照数的下标，并记录
    while (i &lt; j &amp;&amp; array[i] &lt; value) {
      i++
    }

    if (i &lt; j) {
      arr[j--] = arr[i]
    }
  }

  arr[i] = value

  quickSort(array, start, i - 1)
  quickSort(array, i + 1, end)
}
</code></pre>
<h2>插入排序</h2>
<ol>
<li>简单的实现</li>
</ol>
<pre><code class="language-js">var arr = [2, 1, 4, 3, 5]
function insertSort(array) {
  const len = array.length
  // 定义有序数组最后一个索引；
  let preIndex
  // 定义无序数组第一个值；
  let current
  for (let i = 1; i &lt; len; i++) {
    preIndex = i - 1
    current = arr[i]
    // 插入操作
    while (preIndex &gt;= 0 &amp;&amp; current &lt; arr[preIndex]) {
      array[preIndex + 1] = array[preIndex]
      preIndex--
    }
    array[preIndex + 1] = current
  }
  return array
}
insertSort(arr)
</code></pre>
<ol start="2">
<li>使用 reduce 实现</li>
</ol>
<pre><code class="language-js">const insertSort = (array) =&gt; array.reduce(insert, [])
const insert = (sortedArray, value) =&gt; {
  const len = sortedArray.length
  let j = len - 1
  while (j &gt;= 0 &amp;&amp; sortedArray[j] &gt; value) {
    sortedArray[j + 1] = sortedArray[j]
    j--
  }
  sortedArray[j + 1] = value
  return sortedArray
}
insertSort([2, 4, 3, 1])
</code></pre>
<h2>二分查找</h2>
<p>二分查找插入法</p>
<pre><code class="language-js">const insert = (sortedArray, value) =&gt; {
  const length = sortedArray.length
  if (length === 0) {
    sortedArray.push(value)
    return sortedArray
  }
  let i = 0
  let j = length
  let mid
  if (value &lt; sortedArray[0]) {
    return sortedArray.unshift(value), sortedArray
  }
  if (value &gt;= sortedArray[length - 1]) {
    return sortedArray.push(value), sortedArray
  }
  // 开始二分查找
  while (i &lt; j) {
    mid = ((i + j) / 2) | 0
    if (i === mid) {
      break
    }
    if (value &lt; sortedArray[mid]) {
      j = mid
    }
    if (value &gt; sortedArray[mid]) {
      i = mid
    }
  }
  let midArray = [value]
  let lastArray = sortedArray.slice(i + 1)
  sortedArray = sortedArray
    .slice(0, i + 1)
    .concat(midArray)
    .concat(lastArray)
  return sortedArray
}
</code></pre>
<h2>Timsort 实现</h2>
<p>结合归并排序与插入排序</p>
<h2>交换星号</h2>
<p>题目：一个字符串中只包含 _ 和数字，请把 _ 号都放开头。</p>
<pre><code class="language-js">;[&quot;*&quot;, 1, 2, &quot;*&quot;].reduce((arr, value) =&gt; {
  const length = arr.length
  let i = 0
  if (value === &quot;*&quot;) {
    while (i &lt; length) {
      if (arr[i] != &quot;*&quot;) {
        break
      }
      i++
    }
    let lastArr = arr.slice(i)
    return arr.slice(0, i).concat([&quot;*&quot;]).concat(lastArr)
  } else {
    arr.push(value)
    return arr
  }
}, [])
</code></pre>
<h2>最长不重复子串</h2>
<ol>
<li>暴力解法</li>
</ol>
<pre><code class="language-js">var str1 = &quot;abcabcbb&quot;

function getLongestStr(str) {
  const len = str.length
  let start = 0
  let end = 1
  // let subStr = &#x27;&#x27;;
  let max = 0
  for (let i = 0; i &lt; len; i++) {
    let subStr = &quot;&quot;
    for (let j = i; j &lt; len; j++) {
      if (subStr.indexOf(str[j]) === -1) {
        subStr += str[j]
        console.log(subStr)
      } else {
        max = subStr.length &gt; max ? subStr.length : max
        break
      }
    }
  }
  return max
}
getLongestStr(str1)
</code></pre>
<ol start="2">
<li>滑动窗口解法，保证窗口[i..j]之间没有重复字符</li>
</ol>
<pre><code class="language-js">let str1 = &quot;acdafbfsifaadcsacddeac&quot;
function getLongestSubstr(str) {
  let obj = {}
  let result = 0
  let len = str.length
  for (let i = 0, j = 0; ; i++) {
    // 获取窗口的结束位置
    while (j &lt; len &amp;&amp; !obj[str[j]]) {
      obj[str[j++]] = true
    }
    // 得到子串的长度
    result = Math.max(result, j - i)
    // 循环结束
    if (j &gt;= len) {
      console.log(i, j)
      break
    }
    // 获取窗口的开始位置
    while (str[i] != str[j]) {
      obj[str[i++]] = false
    }
    obj[str[i]] = false
  }
  console.log(obj)
  return result
}
getLongestSubstr(str1)
</code></pre>
<h2>爬楼梯算法</h2>
<p>题目：假设我们需要爬一个楼梯，这个楼梯一共有 N 阶，可以一步跨越 1 个或者 2 个台阶，那么爬完楼梯一共有多少种方式？</p>
<ol>
<li>普通递归解法</li>
</ol>
<pre><code class="language-js">let num = 10
function getSteps(n) {
  if (n === 1) return 1
  if (n === 2) return 2
  return getSteps(n - 1) + getSteps(n - 2)
}
getSteps(num)
</code></pre>
<ol start="2">
<li>优化递归解法</li>
</ol>
<pre><code class="language-js">let num = 10
function getSteps(n) {
  let arr = []
  const step = (n) =&gt; {
    if (n === 1) return 1
    if (n === 2) return 2
    if (arr[n] &gt; 0) return arr[n]
    arr[n] = step(n - 1) + step(n - 2)
    return arr[n]
  }
  return step(n)
}
getSteps(num)
</code></pre>
<h2>所有数相加（回溯算法）</h2>
<p>题目：给定一组不含重复数字的非负数组和一个非负目标数字，在数组中找出所有数加起来等于给定的目标数字的组合。</p>
<pre><code class="language-js">const array = [2, 3, 6, 7]
const target = 7
const find = (array, target) =&gt; {
  // 结果数组
  let result = []
  // 深度优先遍历,数组索引,目标和,临时数组
  const dfs = (index, sum, tmpArray) =&gt; {
    if (sum === target) {
      result.push(tmpArray.slice())
    }
    // 如果大于,则直接返回
    if (sum &gt; target) {
      return
    }
    // 这里是关键代码
    for (let i = index; i &lt; array.length; i++) {
      tmpArray.push(array[i])
      dfs(i, sum + array[i], tmpArray)
      tmpArray.pop()
    }
  }
  dfs(0, 0, [])
  return result
}
</code></pre>
<p>高级解法：</p>
<pre><code class="language-js">var combinationSum = function (
  candidates,
  target,
  finalArr = [],
  currArr = [],
  startFrom = 0
) {
  if (target &lt; 0) {
    return finalArr
  }
  if (target === 0) {
    finalArr.push(currArr.slice())
    return finalArr
  }
  for (let i = startFrom; i &lt; candidates.length; i++) {
    const currCandidate = candidates[i]
    currArr.push(currCandidate)
    combinationSum(candidates, target - currCandidate, finalArr, currArr, i)
    currArr.pop()
  }
  return finalArr
}
</code></pre>
<h2>深度遍历</h2>
<pre><code class="language-js">function bfs(node) {
  var queue = []
  let result = []
  queue.push(node)
  while (queue.length) {
    var item = queue.shift()
    result.push(item.value)
    item.left &amp;&amp; queue.push(item.left)
    item.right &amp;&amp; queue.push(item.right)
  }
  return result
}
var node = {
  value: 0,
  left: { value: 1, left: { value: 3 }, right: { value: 4 } },
  right: { value: 2 },
}
console.log(bfs(node))
</code></pre>
<h2>从一个数组中找出 N 个数，其和为 M 的所有可能。</h2>
<p>讲解文章：https://juejin.im/post/5c81fee66fb9a049b82b4128</p>
<pre><code class="language-js">const find = (array, target, sum) =&gt; {
  const len = array.length
  let result = []

  for (let i = 0; i &lt; Math.pow(2, len); i++) {
    if (getCount(i) == target) {
      let s = 0
      let temp = []
      for (let j = 0; j &lt; len; j++) {
        if (i &amp; (1 &lt;&lt; (len - 1 - j))) {
          s += array[j]
          temp.push(array[j])
        }
      }
      if (s == sum) {
        result.push(temp)
      }
    }
  }
  return result
}

function getCount(i) {
  let count = 0
  while (i) {
    if (i &amp; 1) {
      ++count
    }
    i &gt;&gt;= 1
  }
  return count
}

const result = find([1, 2, 3, 4], 2, 4)
console.log(result)
</code></pre>
<h2>有序数组去重，返回去重后数组的新长度</h2>
<pre><code class="language-js">let array = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]
function removeDup(arr) {
  let newArr = []
  let len = arr.length
  let result = 0
  for (let i = 0; i &lt; len - 1; i++) {
    if (newArr.indexOf(arr[i]) === -1) {
      result++
      newArr.push(arr[i])
    }
  }
  console.log(newArr)
  return result
}
removeDup(array)
</code></pre>
<h2>求数组中的众数</h2>
<ol>
<li>普通解法：</li>
</ol>
<pre><code class="language-js">let arr = [3, 3, 2]
function getMostNum(arr) {
  let map = {}
  for (let i = 0; i &lt; arr.length; i++) {
    if (!map[arr[i]]) {
      map[arr[i]] = 1
    } else {
      map[arr[i]]++
    }
    if ((map[arr[i]] &gt; arr.length / 2) | 0) {
      return arr[i]
    }
  }
}
getMostNum(arr)
</code></pre>
<ol start="2">
<li>高效解法：</li>
</ol>
<pre><code class="language-js"></code></pre></div></main></main><script src="/_next/static/chunks/webpack-115ca99861fb5e3b.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/66f30814ff6d7cdf.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/media/92f44bb82993d879-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n3:HL[\"/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n4:HL[\"/_next/static/media/e11418ac562b8ac1-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n5:HL[\"/_next/static/css/3dc4fd6616f3b556.css\",\"style\"]\n6:HL[\"/_next/static/css/cb67a214fed64752.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"7:I[5751,[],\"\"]\na:I[9275,[],\"\"]\nc:I[1343,[],\"\"]\nd:I[9512,[\"291\",\"static/chunks/291-6bbee38a07e9cada.js\",\"653\",\"static/chunks/653-0f61c3cc319dfe42.js\",\"185\",\"static/chunks/app/layout-b94baf518cfbd882.js\"],\"ThemeProvider\"]\ne:I[8871,[\"291\",\"static/chunks/291-6bbee38a07e9cada.js\",\"653\",\"static/chunks/653-0f61c3cc319dfe42.js\",\"185\",\"static/chunks/app/layout-b94baf518cfbd882.js\"],\"default\"]\n10:I[6130,[],\"\"]\nb:[\"slug\",\"%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95\",\"d\"]\n11:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/3dc4fd6616f3b556.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L7\",null,{\"buildId\":\"BTw4ukLj8spDBjleUbwmS\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/blog/%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"前端经典算法\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L8\",\"$L9\"],null],null]},[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$b\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/cb67a214fed64752.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]]}],null]},[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"suppressHydrationWarning\":true,\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"sizes\":\"any\"}],[\"$\",\"body\",null,{\"className\":\"__variable_c1e5c9 __variable_3a0388\",\"children\":[\"$\",\"$Ld\",null,{\"attribute\":\"class\",\"children\":[[\"$\",\"$Le\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex max-w-2xl w-2xl mx-auto bg-gradient\",\"children\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}]}]]}]}]]}],null],null],\"couldBeIntercepted\":false,\"initialHead\":[false,\"$Lf\"],\"globalErrorComponent\":\"$10\",\"missingSlots\":\"$W11\"}]]\n"])</script><script>self.__next_f.push([1,"f:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"kunsun.me\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Generated by create next app\"}],[\"$\",\"meta\",\"4\",{\"name\":\"next-size-adjust\"}]]\n8:null\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"main\",null,{\"className\":\"font-mono\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"前端经典算法\"}],[\"$\",\"div\",null,{\"className\":\"text-[14px] text-tertiary mt-1\",\"children\":\"2021-02-02\"}],[\"$\",\"div\",null,{\"className\":\"markdown mt-10\",\"children\":\"$L12\"}]]}]\n"])</script><script>self.__next_f.push([1,"12:[[\"$\",\"h2\",null,{\"children\":\"尾递归\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"洗牌算法\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"Array.prototype.shuffle = function () {\\n  let arr = this\\n  let length = arr.length\\n  while (length) {\\n    let random = Math.floor(Math.random() * length--)\\n    console.log(length)\\n    let temp = arr[length]\\n    arr[length] = arr[random]\\n    arr[random] = temp\\n  }\\n  return arr\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"快速排序\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"初级实现：\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"var arr = [1, 5, 4, 3, 2]\\nfunction quickSort(arr) {\\n  const len = arr.length\\n  console.log(len)\\n  if (len \u003c= 1) {\\n    return arr.slice()\\n  }\\n  let leftArr = []\\n  let rightArr = []\\n  let middleArr = []\\n  for (let i = 0; i \u003c len; i++) {\\n    if (arr[i] \u003c arr[len - 1]) {\\n      leftArr.push(arr[i])\\n    } else if (arr[i] === arr[len - 1]) {\\n      middleArr.push(arr[i])\\n    } else {\\n      rightArr.push(arr[i])\\n    }\\n  }\\n  return quickSort(leftArr).concat(middleArr, quickSort(rightArr))\\n}\\nquickSort(arr)\\n\"}]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"在原数组中操作：\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"var arr = [4, 1, 5, 3, 2]\\nvar arr1 = [2, 1, 4, 3, 5]\\nconst quickSort = (array, start, end) =\u003e {\\n  start = start === undefined ? 0 : start\\n  end = end === undefined ? arr.length - 1 : end\\n  if (start \u003e= end) {\\n    return\\n  }\\n  let value = array[start]\\n  let i = start\\n  let j = end\\n  while (i \u003c j) {\\n    // 找出右边第一个小于参照数的下标并记录\\n    while (i \u003c j \u0026\u0026 array[j] \u003e= value) {\\n      j--\\n    }\\n\\n    if (i \u003c j) {\\n      arr[i++] = arr[j]\\n    }\\n\\n    // 找出左边第一个大于参照数的下标，并记录\\n    while (i \u003c j \u0026\u0026 array[i] \u003c value) {\\n      i++\\n    }\\n\\n    if (i \u003c j) {\\n      arr[j--] = arr[i]\\n    }\\n  }\\n\\n  arr[i] = value\\n\\n  quickSort(array, start, i - 1)\\n  quickSort(array, i + 1, end)\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"插入排序\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"简单的实现\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"var arr = [2, 1, 4, 3, 5]\\nfunction insertSort(array) {\\n  const len = array.length\\n  // 定义有序数组最后一个索引；\\n  let preIndex\\n  // 定义无序数组第一个值；\\n  let current\\n  for (let i = 1; i \u003c len; i++) {\\n    preIndex = i - 1\\n    current = arr[i]\\n    // 插入操作\\n    while (preIndex \u003e= 0 \u0026\u0026 current \u003c arr[preIndex]) {\\n      array[preIndex + 1] = array[preIndex]\\n      preIndex--\\n    }\\n    array[preIndex + 1] = current\\n  }\\n  return array\\n}\\ninsertSort(arr)\\n\"}]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"使用 reduce 实现\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const insertSort = (array) =\u003e array.reduce(insert, [])\\nconst insert = (sortedArray, value) =\u003e {\\n  const len = sortedArray.length\\n  let j = len - 1\\n  while (j \u003e= 0 \u0026\u0026 sortedArray[j] \u003e value) {\\n    sortedArray[j + 1] = sortedArray[j]\\n    j--\\n  }\\n  sortedArray[j + 1] = value\\n  return sortedArray\\n}\\ninsertSort([2, 4, 3, 1])\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"二分查找\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"二分查找插入法\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const insert = (sortedArray, value) =\u003e {\\n  const length = sortedArray.length\\n  if (length === 0) {\\n    sortedArray.push(value)\\n    return sortedArray\\n  }\\n  let i = 0\\n  let j = length\\n  let mid\\n  if (value \u003c sortedArray[0]) {\\n    return sortedArray.unshift(value), sortedArray\\n  }\\n  if (value \u003e= sortedArray[length - 1]) {\\n    return sortedArray.push(value), sortedArray\\n  }\\n  // 开始二分查找\\n  while (i \u003c j) {\\n    mid = ((i + j) / 2) | 0\\n    if (i === mid) {\\n      break\\n    }\\n    if (value \u003c sortedArray[mid]) {\\n      j = mid\\n    }\\n    if (value \u003e sortedArray[mid]) {\\n      i = mid\\n    }\\n  }\\n  let midArray = [value]\\n  let lastArray = sortedArray.slice(i + 1)\\n  sortedArray = sortedArray\\n    .slice(0, i + 1)\\n    .concat(midArray)\\n    .concat(lastArray)\\n  return sortedArray\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Timsort 实现\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"结合归并排序与插入排序\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"交换星号\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"题目：一个字符串中只包含 _ 和数字，请把 _ 号都放开头。\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\";[\\\"*\\\", 1, 2, \\\"*\\\"].reduce((arr, value) =\u003e {\\n  const length = arr.length\\n  let i = 0\\n  if (value === \\\"*\\\") {\\n    while (i \u003c length) {\\n      if (arr[i] != \\\"*\\\") {\\n        break\\n      }\\n      i++\\n    }\\n    let lastArr = arr.slice(i)\\n    return arr.slice(0, i).concat([\\\"*\\\"]).concat(lastArr)\\n  } else {\\n    arr.push(value)\\n    return arr\\n  }\\n}, [])\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"最长不重复子串\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"暴力解法\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"var str1 = \\\"abcabcbb\\\"\\n\\nfunction getLongestStr(str) {\\n  const len = str.length\\n  let start = 0\\n  let end = 1\\n  // let subStr = '';\\n  let max = 0\\n  for (let i = 0; i \u003c len; i++) {\\n    let subStr = \\\"\\\"\\n    for (let j = i; j \u003c len; j++) {\\n      if (subStr.indexOf(str[j]) === -1) {\\n        subStr += str[j]\\n        console.log(subStr)\\n      } else {\\n        max = subStr.length \u003e max ? subStr.length : max\\n        break\\n      }\\n    }\\n  }\\n  return max\\n}\\ngetLongestStr(str1)\\n\"}]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"滑动窗口解法，保证窗口[i..j]之间没有重复字符\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"let str1 = \\\"acdafbfsifaadcsacddeac\\\"\\nfunction getLongestSubstr(str) {\\n  let obj = {}\\n  let result = 0\\n  let len = str.length\\n  for (let i = 0, j = 0; ; i++) {\\n    // 获取窗口的结束位置\\n    while (j \u003c len \u0026\u0026 !obj[str[j]]) {\\n      obj[str[j++]] = true\\n    }\\n    // 得到子串的长度\\n    result = Math.max(result, j - i)\\n    // 循环结束\\n    if (j \u003e= len) {\\n      console.log(i, j)\\n      break\\n    }\\n    // 获取窗口的开始位置\\n    while (str[i] != str[j]) {\\n      obj[str[i++]] = false\\n    }\\n    obj[str[i]] = false\\n  }\\n  console.log(obj)\\n  return result\\n}\\ngetLongestSubstr(str1)\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"爬楼梯算法\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"题目：假设我们需要爬一个楼梯，这个楼梯一共有 N 阶，可以一步跨越 1 个或者 2 个台阶，那么爬完楼梯一共有多少种方式？\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"普通递归解法\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"let num = 10\\nfunction getSteps(n) {\\n  if (n === 1) return 1\\n  if (n === 2) return 2\\n  return getSteps(n - 1) + getSteps(n - 2)\\n}\\ngetSteps(num)\\n\"}]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"优化递归解法\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"let num = 10\\nfunction getSteps(n) {\\n  let arr = []\\n  const step = (n) =\u003e {\\n    if (n === 1) return 1\\n    if (n === 2) return 2\\n    if (arr[n] \u003e 0) return arr[n]\\n    arr[n] = step(n - 1) + step(n - 2)\\n    return arr[n]\\n  }\\n  return step(n)\\n}\\ngetSteps(num)\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"所有数相加（回溯算法）\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"题目：给定一组不含重复数字的非负数组和一个非负目标数字，在数组中找出所有数加起来等于给定的目标数字的组合。\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const array = [2, 3, 6, 7]\\nconst target = 7\\nconst find = (array, target) =\u003e {\\n  // 结果数组\\n  let result = []\\n  // 深度优先遍历,数组索引,目标和,临时数组\\n  const dfs = (index, sum, tmpArray) =\u003e {\\n    if (sum === target) {\\n      result.push(tmpArray.slice())\\n    }\\n    // 如果大于,则直接返回\\n    if (sum \u003e target) {\\n      return\\n    }\\n    // 这里是关键代码\\n    for (let i = index; i \u003c array.length; i++) {\\n      tmpArray.push(array[i])\\n      dfs(i, sum + array[i], tmpArray)\\n      tmpArray.pop()\\n    }\\n  }\\n  dfs(0, 0, [])\\n  return result\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"高级解法：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"var combinationSum = function (\\n  candidates,\\n  target,\\n  finalArr = [],\\n  currArr = [],\\n  startFrom = 0\\n) {\\n  if (target \u003c 0) {\\n    return finalArr\\n  }\\n  if (target === 0) {\\n    finalArr.push(currArr.slice())\\n    return finalArr\\n  }\\n  for (let i = startFrom; i \u003c candidates.length; i++) {\\n    const currCandidate = candidates[i]\\n    currArr.push(currCandidate)\\n    combinationSum(candidates, target - currCandidate, finalArr, currArr, i)\\n    currArr.pop()\\n  }\\n  return finalArr\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"深度遍历\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function bfs(node) {\\n  var queue = []\\n  let result = []\\n  queue.push(node)\\n  while (queue.length) {\\n    var item = queue.shift()\\n    result.push(item.value)\\n    item.left \u0026\u0026 queue.push(item.left)\\n    item.right \u0026\u0026 queue.push(item.right)\\n  }\\n  return result\\n}\\nvar node = {\\n  value: 0,\\n  left: { value: 1, left: { value: 3 }, right: { value: 4 } },\\n  right: { value: 2 },\\n}\\nconsole.log(bfs(node))\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"从一个数组中找出 N 个数，其和为 M 的所有可能。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"讲解文章：https://juejin.im/post/5c81fee66fb9a049b82b4128\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const find = (array, target, sum) =\u003e {\\n  const len = array.length\\n  let result = []\\n\\n  for (let i = 0; i \u003c Math.pow(2, len); i++) {\\n    if (getCount(i) == target) {\\n      let s = 0\\n      let temp = []\\n      for (let j = 0; j \u003c len; j++) {\\n        if (i \u0026 (1 \u003c\u003c (len - 1 - j))) {\\n          s += array[j]\\n          temp.push(array[j])\\n        }\\n      }\\n      if (s == sum) {\\n        result.push(temp)\\n      }\\n    }\\n  }\\n  return result\\n}\\n\\nfunction getCount(i) {\\n  let count = 0\\n  while (i) {\\n    if (i \u0026 1) {\\n      ++count\\n    }\\n    i \u003e\u003e= 1\\n  }\\n  return count\\n}\\n\\nconst result = find([1, 2, 3, 4], 2, 4)\\nconsole.log(result)\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"有序数组去重，返回去重后数组的新长度\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"let array = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]\\nfunction removeDup(arr) {\\n  let newArr = []\\n  let len = arr.length\\n  let result = 0\\n  for (let i = 0; i \u003c len - 1; i++) {\\n    if (newArr.indexOf(arr[i]) === -1) {\\n      result++\\n      newArr.push(arr[i])\\n    }\\n  }\\n  console.log(newArr)\\n  return result\\n}\\nremoveDup(array)\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"求数组中的众数\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"普通解法：\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"let arr = [3, 3, 2]\\nfunction getMostNum(arr) {\\n  let map = {}\\n  for (let i = 0; i \u003c arr.length; i++) {\\n    if (!map[arr[i]]) {\\n      map[arr[i]] = 1\\n    } else {\\n      map[arr[i]]++\\n    }\\n    if ((map[arr[i]] \u003e arr.length / 2) | 0) {\\n      return arr[i]\\n    }\\n  }\\n}\\ngetMostNum(arr)\\n\"}]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"高效解法：\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\"}]}]]\n"])</script></body></html>